
/** @namespace
  The xt namespace is the primary namespace for all of the node.js
  xt framework. There are many components that makeup the framework
  but all of them belong to the xt namespace exempting third-party
  modules.
  
  It should be noted that many of base functions and functionality
  of the xt namespace were heavily inspired by or parts closely borrowed 
  from SproutCore. They have been adapted to suit specific purposes in this
  context.
*/
xt = { /** @lends xt.prototype */ }

// we load this here because it is used immediately
_ = xt._ = require('underscore');

//.........................................
// Globals
//
// These mimic the SC YES|NO booleans that became
// so convenient they just had to be available.
YES   = true;
NO    = false;

/** @public
  From within a function call `args()` to receive an
  array of the arguments passed into that function.
  
  @returns {Array} array of arguments or empty array
*/
args = function() {
  var a = arguments.callee.caller.arguments;
  if(!a || !a.length) return [];
  return Array.prototype.slice.call(a);
}

/** @private
  Returns a extensible object base-constructor. Used in object
  creation to provide a new object and an extensible prototype.
  
  @returns {Object}
  @static
*/
xt.__p__  = function() { return this; }

/** @private
  Will extend a base object with the properties of any
  objects passed to it. Usually not called directly, should
  use xt.mixin or xt.complete.
  
  @param {Boolean} to override similar keys or not
  @param {Object} the object to extend
  @param {Object} object or objects to use as extension to base
  @returns {Object} the extended base object
  @static
*/
xt.__extend__ = function __extend__(override) {  
  var args = Array.prototype.slice.call(arguments, 1),
      l = args.length,
      b = l > 1 ? args[0] : this || {},
      i = 0, p, t, k;
  for(; i<l; ++i) {
    if(!(p = args[i])) continue;
    for(k in p) {
      if(!p.hasOwnProperty(k)) continue;
      t = p[k];
      if(b === t) continue;
      if(t !== undefined && (override || b[k] === undefined)) b[k] = t;
    }
  }
  return b;
}

/** @private
  Extends a prototype based on many factors.
  
  @param {Object} the prototype to extend
  @param {Object} to extend it by...
  @param {Object} super class
  @returns {Object} extended prototype
*/
xt.__proto_extend__ = function __proto_extend__(b, e, s) {
  b = xt.__extend__(YES, b, e);
  if(e.hasOwnProperty('toString'))
    b.toString = e.toString;
  return b;
}

/** @private
  Creates an instance of a new object based on the object
  passed to it.
  
  @param {Object} the object that will become the prototype of the new object
  @returns {Object} the instance of the new object
*/
xt.__sire__ = function __sire__(b) {
  var n = xt.__p__, r;
  n.prototype = b;
  r = new n;
  n.prototype = null;
  return r;
}

/** @private
  
  @todo The naming and location of this method are suspect
  
  Tests whether or not the object is an xt.object. Returns
  true on positive evaluation, false on negative evaluation.
  Instead of calling this directly, call xt.typeOf and test for
  xt.t_object since that method uses this method to determine
  type or xt.kindOf to directly compare them.
  
  @param {Object} the object to test
  @returns {Boolean} true if the object is an xt.object or false
*/
xt.__isObject__ = function __isObject__(o) {
  if(xt.none(o)) return NO;
  if(
    o.constructor
    && o.__super__
    && o.__xt_object__
    && o.__proto__
  ) return YES;
  return NO;
}

/** @public
  Will extend the target object by the properties in any of the
  additional objects passed to it. Any common keys on the base will
  be overridden by the properties of the last object to supply a
  value for the key. If you wish to only add keys that did not
  previously exist use xt.complete.
  
  @param {Object} the object to extend
  @param {Object} object or objects to use as extension to target
  @returns {Object} the extended target
  @static
*/
xt.mixin = function mixin() {
  var args = Array.prototype.slice.call(arguments);
  args.unshift(YES);
  return xt.__extend__.apply(this, args);
}

/** @public
  Will extend the target object by any properties in any of the
  additional objects passed to it that it did not previously have.
  No properties will be overridden if they are common to it.
  
  @param {Object} the object to extend
  @param {Object} object or objects to use as extension to target
  @returns {Object} the extended target
  @static
*/
xt.complete = function complete() {
  var args = Array.prototype.slice.call(arguments);
  args.unshift(NO);
  return xt.__extend__.apply(this, args);
}

xt.mixin({
  
  /** @public
    Returns whether or not the object is null or nullish.
    
    @param {Object} the object to test on
    @returns {Boolean} true if the object is nullish, false otherwise
  */
  none: function none(o) {
    return !!(_.isNull(o) || typeof o === xt.t_undefined);
  },
  
  //..................................................
  // Globals
  //
  t_string:     'string',
  t_object:     'object',
  t_null:       'null',
  t_class:      'class',
  t_hash:       'hash',
  t_function:   'function',
  t_undefined:  'undefined',
  t_number:     'number',
  t_boolean:    'boolean',
  t_array:      'array',
  t_regex:      'regex',
  t_error:      'error',
  
  // this needs to be read from the configuration file
  version: '0.1.1Alpha',
  
  /** @public
    Returns the type as defined in the global types.
    
    @param {Object} the object to determine its type
    @returns {String} the type if it could be determined
  */
  typeOf: function typeOf(o) {
    if(xt.none(o)) return xt.t_null;
    if(xt._.isFunction(o)) return xt.t_function;
    else if(_.isNumber(o)) return xt.t_number;
    else if(_.isBoolean(o)) return xt.t_boolean;
    else if(_.isString(o)) return xt.t_string;
    else if(_.isArray(o) || !xt.none(o.length)) return xt.t_array;
    else if(_.isRegExp(o)) return xt.t_regex;
    else {
      if(xt.__isObject__(o)) return xt.t_object;
      else return xt.t_hash;
    }
    // @todo NEEDS TO HANDLE ERROR TYPE!
  },
  
  /** @public
    Returns true if the type of the object is the same as
    the object's class.
    
    @param {Object} the object to compare
    @param {Object} the object class to compare against
    @returns {Boolean} true if the object is the same as class
  */
  kindOf: function kindOf(o, c) {
    if(xt.none(o) || !o.constructor) return NO;
    return !!(o.constructor === c);
  },
  
  /** @private
    Initialization routine for objects based on xt.object.
    
    @param {Object...} hashes to extend the xt.object instance
    @returns {Object} instance of xt.object or child
  */
  __init__: function __init__() {
    var l = arguments.length,
        i = 0;
    for(; i<l; ++i) { xt.__extend__.call(this, YES, arguments[i]); }
    this.uid = _.uniqueId('_xt_');
    if(xt.typeOf(this.init) === xt.t_function) this.init();
    return this;
  },
  
  /** @private
    @see xt.object.set
  */
  __set__: function __set__() {
    if(arguments.length < 2) return this;
    var a = arguments,
        p = a[0],
        v = a[1], 
        c = this,
        i = p.indexOf('.'), s, t;
    
    // @todo Should really throw warnings when fail cases occur
    
    // @todo Maybe regex instead?
    while(i == 0) {
      p = p.slice(1);
      i = p.indexOf('.');
    }
    if(!~i)
      this[p] = v;
    else {
      s = p.split('.');
      while(s.length > 0) {
        t = s.shift();
        if(s.length == 0) c[t] = v;
        else {
          if(xt.none(c[t]))
            c[t] = {};
          c = c[t];
        }
      }
    }
    
    return this;
    
    // @todo Event handling/notifications still missing
  },
  
  /** @private
    @see xt.object.get
  */
  __get__: function __get__() {
    if(arguments.length == 0) return undefined;
    var a = arguments,
        t = arguments[0], 
        c = this,
        i = t.indexOf('.'), v, p, k;
    
    // @todo Maybe regex instead?
    while(i == 0) {
      t = t.slice(1);
      i = t.indexOf('.');
    }
    if(!~i) 
      v = c[t];
    else {
      p = t.substring(0, i);
      t = t.slice(i);
      k = xt.typeOf(c[p]);
      if(k === xt.t_object || k === xt.t_hash)
        v = xt.__get__.call(c[p], t);
      else return undefined;
    }
    return v;
  },
  
  /** @public
    Takes either a string or an object and converts it to the
    opposing JSON form. If a string is provided it will attempt
    to parse the string into a JSON object - if an object is
    provided it will attempt to parse it into JSON string form.
    This is a synchronous function.
    
    @param {String|Object} the JSON to convert
    @returns {String|Object} the correct JSON converted form
  */
  json: function json(j) {
    var t = xt.typeOf(j);
    try {
      if(t === xt.t_hash) {
        j = JSON.stringify(j);
      } else if(t === xt.t_string) {
        j = JSON.parse(j);
      }
    } catch(e) { xt.warn(e); }
    return j;
  },
  
  /** @private
    Parses a configuration file if one was provided instead of command-
    line arguments.
    
    @param {String} filepath (from command-line)
  */
  parseConfiguration: function parseConfiguration(f) {
    f = xt.fs.__path__.resolve(xt.fs.basePath, f);
    xt.fs.readFile(f, function(e, d) {
      if(e) throw xt.fatal(e);
      xt.mixin(xt.opts, xt.json(d));
      process.emit('xtReady');
    })
  }
}) ;

/** @lends xt.object */     require('object');
/** @lends xt.io */         require('io');
/** @lends xt.exception */  require('exception');
/** @lends xt.proto */      require('proto');
/** @lends xt.filesystem */ require('filesystem');
/** @lends xt.opts */       require('opts');
