

/** @namespace
  Exception handling for the process.
*/
xt.exception = xt.object.create(
  /** @scope xt.exception.prototype */ {
    
  /** @private
    All manageable exceptions encountered during runtime
    will be handed to this method to be dealt with properly.
    An appropriately thrown error will minimally have
    a type and a message and can have an array of arguments to
    be applied to the handler for that type.
    
    @param {Object} the object hash returned from the exception
  */
  handle: function(e) {
    var s = xt.exception;
    switch(e.type) {
      case xt.exception.t_warning:
      case xt.exception.t_close:
      case xt.exception.t_report:
        xt.warn("Exception encountered", e);
        break;
      case xt.exception.t_fatal:
        xt.err("Error encountered", e);
        s.count += 1;
        break;
      default:
        xt.err("Unrecoverable exception", e);
        xt.trucking = NO;
        break;
    }
    if(s.count > 5) throw xt.fatal("Too many errors encountered");
  },
    
  //...........................................
  // Types of Exceptions
  //
  t_fatal:    'fatal',
  t_warning:  'warning',
  t_close:    'close',
  t_report:   'report',
  
  fatal: function() {
    var m = arguments[0];
    return { type: 'fatal', message: m };
  },
  
  warning: function() {
    var m = arguments[0];
    return { type: 'warning', message: m };
  },
  
  close: function() {
    var a = args(),
        m = a.shift();
    return { type: 'close', message: m, args: a };
  },
  
  count: 0,
  
  /** @private */
  className: 'xt.exception'
    
}) ;

// Convenience
xt.fatal    = xt.exception.fatal;
xt.warning  = xt.exception.warning;
xt.close    = xt.exception.close;

xt.trucking = YES;

//................................................
// Need to handle specific events
// 
// When some unhandled exception is throw, not much we can
// but report it
process.on('uncaughtException', xt.exception.handle);