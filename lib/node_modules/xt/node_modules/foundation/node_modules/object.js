
/** @class
  The xt.object class is the base class for nearly all custom
  objects in the xt framework for node.js server.
  
  @param {Object...} hashes or a hash to extend from
  @returns {Object} a new instance of an xt.object or child of xt.object
*/
xt.object = function() { 
  this.__super__ = xt.object.prototype;
  return xt.__init__.apply(this, arguments[0]); 
}

//.............................................
// Class Extensions
//
// These methods make using xt.object's more convenient and allow
// for easy extensibility and inheritance.
xt.mixin(xt.object,
  /** @scope xt.object.constructor */ {
  
  /** @public
    Creates a new object based on this object type. Accepts hashes
    for extension that will create either a new class type as a singleton
    or simply a new object of this type with properties initialized to
    the given values.
    
    @param {Object...} hashes of properties to extend this object with
    @returns {Object} an instance of the object
  */
  create: function create() { 
    var c = this, r = new c(arguments); return r; 
  },
  
  /** @public
    Extends the base object with the given properties. It creates a new class
    that inherits from the base. Can take any number of key-value hashes to
    extend the base with that redefine it as a new class or simply the same base
    class with different properties at initialization.
    
    @param {Object...} hashes to extend the base with
    @returns {Object} class extending from parameters
  */
  extend: function extend() {
    var r = function() { return xt.__init__.apply(this, arguments[0]); },
        l = arguments.length,
        i = 0, k, p;
    for(k in this)
      if(!this.hasOwnProperty(k)) continue;
      else r[k] = this[k];
    p = (r.prototype = xt.__sire__(this.prototype));
    for(; i<l; ++i)
      xt.__proto_extend__(p, arguments[i], this.prototype);
    p.constructor = r;
    p.__super__ = this.prototype;
    return r;
  },
  
  /** @private
    Simple mechanism to differentiate between instance and class.
  */
  toString: function() { 
    var c = this.className
      || this.prototype.className;
    return "[ CLASS: %@ ]".format(c);
  }
  
}) ;

/** @scope xt.object.prototype */
xt.object.prototype = {
  
  /** @private
    
    @todo This has things to do...
  */
  init: function() {},
  
  /** @public
    Set a property on the given object to be equal to a specified
    value. This is essentially meta-data of the object and can be
    referenced and manipulated many ways but also allows for types
    of notifications to take place.
    
    @param {String} the path for the property to set relative to this
    @param {Object} any type of object that be assigned
    @returns {Object} this
  */
  set: function() {
    return xt.__set__.apply(this, arguments);
  },
  
  /** @public
    Retrieve a value for the given property path on the object.
    
    @returns {Object|Boolean} the value for the key or undefined if not found
  */
  get: function() {
    return xt.__get__.apply(this, arguments);
  },
  
  /** @private
    Each class should have a name. This name is used in several
    ways of matching types, retrieving classes from strings,
    comparisons, etc.
  */
  className: 'xt.object',
  
  /** @private
    While this method can be overridden, most cases it won't be.
    It provides a consistent, accurate and relatively convenient
    human-readable output for debugging (mostly) but sometimes
    comparisons.
    
    @returns {String} the string for the object
  */
  toString: function toString() {
    var c = this.className || 'NOCLASS',
        g = this.uid || 'NOUID';
    return "[ %@ (%@) ]".format(c, g);
  }
}

// We want for xt.objects to inherit from EventEmitter so they can
// automatically handle events
xt.mixin(xt.object.prototype, require('events').EventEmitter.prototype);