create or replace function private.model_changed() returns trigger as $$
-- Copyright (c) 1999-2011 by OpenMFG LLC, d/b/a xTuple. 
-- See www.xm.ple.com/CPAL for the full text of the software license.
declare
  i integer;
  cols text[] := '{}';
  tbls text[] := '{}';
  clauses text[] = '{}';
  comments text = 'System view generated by model tables: WARNING! Do not make changes or add rules directly to this view!';
  rules text[] = '{}';
  query text;
  rec record;
  m_name text;
  s_name text;
begin

  -- Validation
  if tg_op in ('INSERT','UPDATE') then
    if tg_table_name = 'modelext' then
      if coalesce(new.modelext_seq,-1) < 0 then
        raise exception 'Model extension sequence must be greater than zero';
      end if;
    end if;
    m_name = new.model_name;
  else
    m_name = old.model_name;
  end if;
  
  -- Remove old vew and determine whether to rebuild
  if tg_op in ('UPDATE', 'DELETE') then
    perform dropIfExists('VIEW', old.model_name, 'xm');

    -- Bail out in specific cases where it is a base model
    if tg_table_name = 'model' then
      if tg_op = 'DELETE' then
        return old;
      elsif tg_op = 'UPDATE' and not new.model_active then
        return old;
      end if;
    end if;

  else
    perform dropIfExists('VIEW', new.model_name, 'xm');
  end if;
  
  -- Loop through models and build components
  i := 1;
  
  for rec in
    select model_id, model_columns, model_schema_name, model_table_name, 
      model_conditions, model_rules, model_comment,
      false as ext, null as modelext_join_type, null modelext_join_clause, 
      -1 as modelext_seq
    from only private.model
    where model_name = m_name
    union
    select model_id, model_columns, model_schema_name, model_table_name, 
      model_conditions, model_rules, model_comment,
      true as ext, modelext_join_type, modelext_join_clause, 
      modelext_seq
    from private.modelext
    where model_name = m_name
    and model_active
    order by modelext_seq, model_id
  loop
    cols := cols || rec.model_columns;

    -- Concatenate join clauses on tables when specified
    if length(rec.model_schema_name) > 0 then
      s_name = rec.model_schema_name || '.';
    else
      s_name = '';
    end if;
    
    if not rec.ext then
      tbls[i] = s_name || rec.model_table_name;
    elsif (rec.modelext_join_type is not null) then
      tbls[i] = rec.modelext_join_type || ' ' || s_name || rec.model_table_name || ' on (' || rec.modelext_join_clause || ')';
    else
      tbls[i] = ', ' || s_name || rec.model_table_name;
    end if;
    
    clauses := clauses || rec.model_conditions;
    
    rules := rules || rec.model_rules;

    if (rec.model_comment is not null) then
      comments := comments || '

'  || rec.model_comment;
    end if;
    
    i := i + 1;
  end loop;

  -- Validate colums
  if array_length(cols, 1) = 0 then
    raise exception 'There must be at least one column defined on the model.';
  end if;
  
  -- Build query to create the new view
  query := 'create view xm.' || m_name || ' as ' ||
         'select ' || array_to_string(cols, ', ') ||
         ' from ' || array_to_string(tbls, ' ');

  if array_length(clauses, 1) > 0 then
    query := query || ' where ' || array_to_string(clauses, ' and ');
  end if;

  -- Create the view
  execute query;

  -- Add comment
  query := 'comment on view xm.' || m_name || E' is \'' || comments || E'\''; 

  execute query;
  
  -- Apply the rules
  for rec in
    select unnest(rules) as rule
  loop
    execute rec.rule;
  end loop;

  -- Grant access to xtrole
  query := 'grant all on xm.' || m_name ||' to xtrole';
  execute query;
  
  -- Finish up
  if tg_op = 'DELETE' then
    return old;
  end if;
  
  return new;
  
end;
$$ language 'plpgsql';
