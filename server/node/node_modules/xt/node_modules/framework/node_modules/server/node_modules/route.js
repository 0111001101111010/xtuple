
// require some core modules
var UTIL    = require("util");
var PATH    = require("path");
var FS      = require("fs");

// load into module namespace from above
require("tools");
require("exception");

//.....................................
// XT.Route object defines handler for request type

XT.Route = XT.Object.extend({

  init: function() {
    // @note This will be needed...
  },

  /** @public
    Router will call this method on the route if one
    of the routes matched. It is passed a single parameter
    that contains the original request/response objects
    as well as parsed data.

    @param {Object} Information and references
  */
  handle: null,

  /** @public
    Must provide routes object in class definition
    so the router can check it via direct index. These
    routes are not the same as the parent routes stored
    on XT.Route.loadedRoutes as those are instances of extended
    XT.Route objects.
  */
  routes: null,

  /** @public
    If the route doesn't require any special headers this
    can be called to prep the response. However, it will need
    to be overridden in nearly all cases.
  */
  prepare: function(xtResponse) {
    xtResponse.serverResponse.setHeader("Content-Type", "text/html");
  },

  /** @private */
  xtClass: "XT.Route",

});

XT.__extend(XT.Route, {

  loadRoutes: function() {
    try {

      // if possible, chdir to the module's directory so we can use relative pathing
      process.chdir(__dirname);

      // read all of the .js files in the ./routes/ directory
      var files = XT.Tools.prepend(
        XT.Tools.fs.readDir("./routes/", [ ".js" ]), "./");

      var routesToLoad = files.length;

      // need to set listener to respond when the actual routes load themselves
      process.on("loadedRoute", function(route) {
        XT.Route.loadedRoutes[ route.xtClass ] = route;
        --routesToLoad; if(routesToLoad === 0) process.emit("allRoutesLoaded");
      });

      // need to set listener to respond to the allRoutesLoaded event
      process.on("allRoutesLoaded", function() {
        
        // the paths => instance-handler for the routes to set on
        // the router
        var pathsToRoutes = {};

        // set all of the routes to point back to the correct route-handler
        XT.Tools.each(XT.Route.loadedRoutes, function(name, instance) {
          var routes = instance.get("routes");
          XT.Tools.each(routes, function(path, dummy) {
            pathsToRoutes[ path ] = instance;
          });
        });

        // replace the loadedRoutes property...
        XT.Route.loadedRoutes = pathsToRoutes;
      });

      // iterate over the filepaths and "require" them so they are included
      // and then executed thus loading themselves and executing the
      // event attached to "routeLoaded" (top)
      XT.Tools.each(files, function(idx, filename) {
        require(filename);
      });
    } catch(e) { XT.throw(new XT.FATAL({ message: e, stack: e.stack })); }
  },

  loadedRoutes: {},

});

XT.Route.loadRoutes.call(XT.Route.prototype);
