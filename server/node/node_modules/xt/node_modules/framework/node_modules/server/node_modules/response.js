
// load into module namespace from above
require("tools");
require("exception");


/** @notes
  
  The XT.Response object needs to handle multiple scenarios for what data types
  of data it will be returning. Right now it can but it is inefficient and cumbersome.
  Since each type will need essentially to go through the same motions but deal
  with different preparations there should be a way to swap contexts for functions
  without changing the function calls...

*/


XT.Response = XT.Object.extend({

  /** @private */
  init: function() {

    // set a new uuid to the new response
    this.set("uuid", XT.Tools.crypto.uuid());

    // parse out some properties from the request object
    var req = this.get("serverRequest");

    // grab the unparsed url
    this.set("url", req.url);

    // grab the request method
    this.set("requestMethod", req.method);

    // grab the content-type if there is one
    this.set("contentType", req.headers[ "content-type" ] || null);

    // grab the client information
    this.set("client", req.client);

    // set the accumulator json object
    this.set("json", {});

    // auto-fire event on relationsStack being set
    this.on("relationStack", this.initStack);

    // if the response needs to handle something OTHER than
    // a record's response the handler sets the `nonRecord`
    // to fire THIS instead...
    this.on("nonRecord", this.initNormal);

  },

  //........................................
  // auto-set properties

  /** @private */
  uuid: null,

  /** @private */
  payloadOut: null,

  /** @private */
  payloadIn: "",

  /** @public */
  url: "",

  /** @public */
  requestMethod: "",

  /** @public */
  contentType: "",

  /** @public */
  client: null,

  /** @public */
  relationStack: null,

  //........................................
  // properties set at instantiation

  /** @private */
  serverResponse: null,

  /** @private */
  serverRequest: null,

  //........................................
  // public methods

  /** @public */
  send: function(packet) {

    // // the object to be stringified and sent
    // var json = {};

    // // the structure of the object is simple,
    // // XT.RecordType => resultset from query
    // json[ packet.returning ] = packet.result;

    // // attempt to stringify it
    // try {

    //   json = JSON.stringify(json);

    // } catch(e) { XT.throw(new XT.FATAL({ message: e, stack: e.stack })); }

    // // on success...write it
    // this.serverResponse.write(json);
    
    if(this.get("useJson")) {
      var json = this.get("json");
      json[ packet.returning ] = packet.result;
      if(!json.sc_types) json.sc_types = [];
      json.sc_types.push(packet.returning); 
      // tell the XT.Response we just sent something...
      this.emit("sent");
    } else {
      var data = this.get("data");
      data += packet;
      this.set("data", data);
    }

    // return reference to xtResponse for chaining
    return this;
  },

  //........................................
  // internal methods

  /** @private */
  initNormal: function() {
    this.set("useJson", false); 
    this.set("data", "");
  },

  /** @private */
  initStack: function() {

    var self = this;

    // when the XT.Response.send method is fired it emits
    // the "sent" event to its self, we catch that to check
    // if we are empty, and, if we are, we close the client
    // connection notifying them all of the data has been transmitted
    this.on("sent", function() {

      // if this is true, we're all done...
      // if not, we have to execute the remaining queries...
      if(self.relationStack.isEmpty()) {
        self.end();
      } else { self.exec(); }
    });

    // since we have a stack of relations we have to fire
    // register a one-time listener for the return of the
    // top-level result to know when we can begin
    this.on("resultSet", function() {

      // go ahead and send the data from the top level
      // query result
      var packet = { returning: self.get("query.sctype"),
        result: self.get("resultSet") };

      // send it off
      self.send(packet);

      // startup the chain of relations actions...
      // self.exec();
    });

  },

  /** @private */
  exec: function() {
    var next = this.get("relationStack").pop();
    next.exec(this.resultSet, this);
  },


  /** @private
    HACKAKACHAKCHKACHKAHCKACHKACHKAHCKAHCKA!!!!!
  */
  noDataReturn: function() {
    this.get("noDataStack").pop();
    if(this.get("noDataStack").isEmpty())
      this.end("");
  },

  /** @private
    HACKHACKHACKHACKHACKHACKHACKHACKHACK!!!!!!!!!!
  */
  sendJson: function(payload) {

    // EXPECTS THAT nonRecord was SET!!!
    // HACKKKKKKKKKKKKKKK
    payload = JSON.stringify(payload);

    XT.puts("Sending JSON payload back to client:\n{0}\n".format(
      XT.inspect(payload, true, true)));
    
    this.serverResponse.setHeader("Content-Type", "application/json");
    this.set("data", payload);
    this.end();  
  },

  /** @private */
  end: function(final) {
    if(final) {
      this.serverResponse.end(final);
    } else {

      if(this.get("useJson")) {

        // else, blob the accumulated response, stringify, send...
        var json = this.get("json");

        try {
        
          json = JSON.stringify(json);

        } catch(e) { XT.throw(new XT.FATAL({ message: e, stack: e.stack })); }

        // XT.puts("\n\nSENDING:");
        // XT.inspect(json);
        // XT.puts("\nFOR {0}".format(this.get("query.sctype")));

        this.serverResponse.end(json);
      } else { this.serverResponse.end(this.get("data")); }
    }
  },

  /** @private */
  useJson: true,

  /** @private */
  xtClass: "XT.Response",


});
