
// require some core modules
var UTIL    = require("util");
var PATH    = require("path");

// load into module namespace from above
require("tools");
require("exception");
require("store");

// load into module namespace from level
require("route");


XT.RecordsRoute = XT.Route.create({

  init: function() {

    // grab the record types that were loaded by the store (just names)
    var recordTypes = XT.Tools.keys(
      XT.Store.recordManager.get("types")), self = this;

    // each one needs a formal route to it
    XT.Tools.each(recordTypes, function(idx, name) {
      self.routes[ "/retrieve/content/{0}".format(name) ] = '';
    });

    // set them so these will be our available routes for records
    this.set("recordTypes", recordTypes);
  },
  
  handle: function(xtResponse) {
    
  
    // XT.puts("HANDLING REQUEST FOR RECORD");

    // XT.inspect(xtResponse);

    // grab the text representation of the record type from the URL
    // var type = xtResponse.url.substring(xtResponse.url.lastIndexOf(".")-2)

    // parse it so we can figure out what the primary action is
    var parsed = xtResponse.url[ 0 ] == "/"
      ? xtResponse.url.substring(1).split("/")
      : xtResponse.url.split("/")
      ;

    // came in the form: /retrieve/content/{XT.Record}
    var type = parsed[ 2 ], form;

    if(!xtResponse.payloadIn || xtResponse.payloadIn === "") {
      
      // assume this means we are trying to retrieve the ENTIRE LIST?
      // so we need to use the SELECTALL query form
      form = "all";
    } else {

      form = "template";

      // attempt to parse the JSON payload
      try {

        xtResponse.payloadIn = JSON.parse(xtResponse.payloadIn); 

      } catch(e) { XT.throw(new XT.FATAL({ message: e, stack: e.stack })); }
    }

    // grab the requested type from the store
    // @note It returns a XT.Query object that was created FOR
    //  that record type, NOT A RECORD of the requested type
    xtResponse.query = XT.Store.fetchQuery(type);

    xtResponse.SQLTYPE = this.determineSqlType(parsed, xtResponse, form);

    xtResponse.SQLTYPEFORM = form;

    this.prepare(xtResponse);
  }, 

  /** @private */
  determineSqlType: function(parsedUrlParts, xtResponse, form) {
    
    if(parsedUrlParts[ 0 ] == "retrieve") {
      return form == "template"
        ? "SELECT"
        : "SELECTALL"
        ;
    } else if(parsedUrlParts[ 0 ] == "commit") {
      if(parsedUrlParts[ 1 ] == "content") {
        var type = xtResponse.get("sctype");
        var actions = xtResponse.payloadIn[ type ];
        var ret = {};
        XT.puts("IN FOR COMMIT...");
        XT.inspect(actions);
        process.exit();
      }
    } else { XT.throw(new XT.FATAL({ message: "COULD NOT DETERMINE SQL ACTION FROM URL?" })); }
  },

  /** @private */
  prepare: function(xtResponse) {

    // set header content-type to json
    xtResponse.serverResponse.setHeader("Content-Type", "application/json");

    // 

    // exec the query
    xtResponse.query.emit("exec", xtResponse);
  },

  /** @private
    These routes are determined based on what the XT.Store
    reports as available XT.Record types.
  */
  routes: {},

  /** @private */
  xtClass: "XT.RecordsRoute",

});

process.emit("loadedRoute", XT.RecordsRoute);
