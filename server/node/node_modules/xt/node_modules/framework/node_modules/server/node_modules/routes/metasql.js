
// require some core modules
var UTIL    = require("util");
var PATH    = require("path");
var HTTP    = require("http");

// load into module namespace from above
require("tools");
require("exception");

// load into module namespace from level
require("route");

XT.MetasqlRoute = XT.Route.create({

  init: function() { },
  
  handle: function(xtResponse) {

    // this will need to be moved once the metasql's are identified dynamically
    xtResponse.set("isMetaSQL", true);

    // as a temporary solution this is just being made into a proxy request to a
    // running ORIGINAL php datasource since we need to either transpose the
    // metasql interpreter to JS (imo terrible idea) or create it as a compilable
    // extension to node.js (imo GOOD IDEA!)

    xtResponse.set("nonRecord");

    // minor editing since we aren't the ones doing the actual db call
    // need to re-add the .php extension
    var urlBase = xtResponse.url.replace(/\/retrieve\/metasql/, "runmetasql.php");


    var tail = XT.METASQL_SOURCE_PATH + "/datasource/" + urlBase;

    // auto-forward request to this temporarily fixed/available url...
    var host = XT.METASQL_SOURCE_URL || "sproutcore.xtuple.org";

    XT.puts("Forwarding MetaSQL request to: {0}{1}".format(host, tail));

    // XT.puts("HEADERS: {0}".format(XT.inspect(xtResponse.serverRequest.headers, true, true)));

    // scope reference for response from proxied request
    var remotePayload = "";

    // we already have the payload (if any) to forward along with the request so...
    // lets get to it
    var proxyRequest = HTTP.request({
      method: "POST",
      path: tail,
      host: host,
      port: XT.METASQL_SOURCE_PORT || 80,
      headers: xtResponse.serverRequest.headers,

      // and when we get the response...
    }, function(remoteResponse) {
      
      // XT.puts("RECEIVED BACK FROM REMOTE:\n {0}".format(XT.inspect(remoteResponse, true, true)));

      // need to fetch any payload data for that of course...
      remoteResponse.on("data", function(chunk) {
        remotePayload += chunk;

        // and when that is all done...
      }).on("end", function() {
        
        // XT.puts("REMOTE PAYLOAD: {0}".format(XT.inspect(remotePayload, true, true)));

        // shove the response into the original request and be done with it
        xtResponse.send(remotePayload).end();
      });
    });

    // now that the responder chain is setup, go ahead and
    // fire the proxy request
    proxyRequest.write(xtResponse.payloadIn);
    proxyRequest.end();
  },

  routes: {

    "/retrieve/metasql/XM.ActivityTable/query":'',
    "/retrieve/metasql/XM.Address/findExisting":'',
    "/retrieve/metasql/XM.Address/useCount":'',
    "/retrieve/metasql/XM.AddressSearch/query":'',
    "/retrieve/metasql/XM.ContactSearch/query":'',
    "/retrieve/metasql/XM.ContactTable/query":'',
    "/retrieve/metasql/XM.CrmAccountSearch/query":'',
    "/retrieve/metasql/XM.CrmAccountTable/query":'',
    "/retrieve/metasql/XM.CustomerShiptoSearch/query":'',
    "/retrieve/metasql/XM.IncidentSearch/query":'',
    "/retrieve/metasql/XM.IncidentTable/query":'',
    "/retrieve/metasql/XM.OpportunitySearch/query":'',
    "/retrieve/metasql/XM.OpportunityTable/query":'',
    "/retrieve/metasql/XM.ProjectTable/query":'',
    "/retrieve/metasql/XM.ProjectSearch/query":'',
    "/retrieve/metasql/XM.ProspectCustomerSearch/query":'',
    "/retrieve/metasql/XM.ProspectTable/query":'',
    "/retrieve/metasql/XM.QuoteSearch/query":'',
    "/retrieve/metasql/XM.QuoteTable/query":'',
    "/retrieve/metasql/XM.Record/nextNumber":'',
    "/retrieve/metasql/XM.Session/privileges":'',
    "/retrieve/metasql/XM.Session/locale":'',
    "/retrieve/metasql/XM.Session/metrics":'',
    "/retrieve/metasql/XM.Session/sourceCommentTypes":'',
    "/retrieve/metasql/XM.UserSearch/query":''

  },

  /** @private */
  xtClass: "XT.MetasqlRoute",

});

process.emit("loadedRoute", XT.MetasqlRoute);
