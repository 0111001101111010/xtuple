
// require some core modules
var UTIL    = require("util");
var PATH    = require("path");

/** @public */
XT.P = function() { return this; };

/** @private */
XT.__beget = function(base) {
  var b = XT.P; b.prototype = base;
  var ret = new b;
  b.prototype = null;
  return ret;
};

/** @private */
XT.__genGuid = function(xtObj) {
  XT.Tools.crypto.guid(xtObj);
};

/** @private */
XT.__instance_extend = function(base, ext) {
  base = XT.__extend(base, ext);
  var key = 'toString';
  if(ext.hasOwnProperty(key))
    base[ key ] = ext[ key ];
  return base;   
};

/** @private */
XT.__extend = function() {
  var args = Array.prototype.slice.call(arguments),
    target = args[ 0 ] || {}, len = args.length,
    idx = 1, props, temp, key;
  for( ; idx<len; ++idx) {
    if(!(props = args[ idx ])) continue;
    for(key in props) {
      if(!props.hasOwnProperty(key)) continue;
      temp = props[ key ];
      if(target === temp) continue;
      if(temp !== undefined) target[ key ] = temp;
    }
  }
  return target;
};

/** @private */
XT.__init = function(props) {
  if(props.length && props.length > 0) {
    var idx, len = (props) ? props.length : 0;
    for(idx=0; idx<len; ++idx)
      XT.__instance_extend(this, props[ idx ]);
  } else { 
    XT.__instance_extend(this, props);
  }
  XT.__genGuid(this);
  if(this.init) this.init();
  return this;
};

/** @public */
XT.Object = function(props) {
  return XT.__init.call(this, props);
};

/** @private */
XT.__extend(XT.Object, {

  /** @public */
  create: function() {
    var b = this, ret = new b(arguments);
    return ret;
  },

  /** @public */
  extend: function(props) {
    var key, ret = function(props) {
      return XT.__init.call(this, props);
    };
    for(key in this) {
      if(!this.hasOwnProperty(key)) continue;
      ret[ key ] = this[ key ];
    }
    if(this.hasOwnProperty('toString')) ret.toString = this.toString;
    var proto = (ret.prototype = XT.__beget(this.prototype));
    var idx, len = arguments.length;
    for(idx=0; idx<len; ++idx)
      XT.__instance_extend(proto, arguments[ idx ]);
    proto.constructor = ret;
    proto.__super = this.prototype;
    return ret;
  },

  /** @public */
  notHidden: function(obj, key) {
    if(obj.isXtObject) {
      if(obj.xtHide && obj.xtHide.length > 0) {
        return ! XT.Tools.in(obj.xtHide, key);
      }
    } else { return true; }
  },
});

/** @private */
XT.Object.prototype = {

  /** @private */
  xtClass: 'XT.Object',

  /** @private */
  toString: function() {
    var xtClass = this.xtClass || "XT.Unitited Object",
    guid = this.guid || "NOGUID";
    var str = "[{0} ({1})]".format(xtClass, guid);
    return str;
  },

  /** @private */
  isXtObject: true,

  /** @private */
  get: function(param) {
    if(typeof param == "string") {
      if(param.indexOf('.') !== -1) {
        var parts = param.split('.'), retObj = this;
          for(var i=0, len=parts.length; i<len; ++i) {
            if(typeof retObj[ parts[ i ] ] != "undefined") {
              retObj = retObj[ parts[ i ] ];
            } else { return false; }
          }
        return retObj;
      } else {
        return typeof this[ param ] != "undefined"
          ? this[ param ]
          : false
          ;
      }
    } else { return false; }
  },
 
  /** @private */
  set: function(path, param) {
    if(typeof path == "string") {
      if(path.indexOf('.') !== -1) {
        var parts = path.split('.'), pathObj = this;
        for(var i=0, len=parts.length; i<len; ++i) {
          if(pathObj[ parts[ i ] ]) {
            pathObj = pathObj[ parts[ i ] ];
          } else if((len-i) === 1) {
            pathObj[ parts[ i ] ] = param;
          } else {
            pathObj = pathObj[ parts[ i ] ] = {};
          }
        }
      } else { this[ path ] = param; }
      this.emit(path, path, param);
      this.emit("*", path, param);
      // return param;
      return this;
    } else { return false; }
  },
 
  /** @private */
  delete: function(path) {
    if(typeof path == "string") {
      if(path.indexOf('.') !== -1) {
        var parts = path.split('.'), pathObj = this;
        for(var i=0, len=parts.length; i<len; ++i) {
          if((len-i) == 1) {
            return delete pathObj[ parts[ i ] ];
          } else if(pathObj[ parts[ i ] ]) {
            pathObj = pathObj[ parts[ i ] ];
          } else {
            XT.throw(XT.WARNING.create({
              message: XT.E201.format(this, path),
            }));
            return false;
          }
          // } else {
          //   process.emit("ERROR", ("{0} can't find the target to delete " +
          //     "({1})").format(this.toString(), path), err.WARNING);
          //   return false;
          // }
        }
      } else { return delete this[ path ]; }
    } else { return false; }
  },
 
   /** @private */
   has: function(path) {
     return this.get(path) !== false
       ? true
       : false
       ;
   },
};

/** @private */
XT.__extend(XT.Object.prototype, require('events').EventEmitter.prototype);

XT.Object.prototype.__super = XT.Object.prototype;





XT.Stack = XT.Object.extend({

  init: function() {
    if(!this.get("stack")) {
      this.set("stack", []);
    } else if(!isNaN(this.get("stack"))) {
      var arr = [];
      for(var i=0, len=this.get("stack"); i<len; ++i)
        arr.push(null);
      this.set("stack", arr);
    }
  },

  push: function(elem) {
    this.get("stack").unshift(elem);
  },

  pop: function() {
    var stack = this.get("stack");
    var ret = stack.length > 0
      ? stack.shift()
      : null
      ;
    if(this.isEmpty())
      this.emit("empty");
    return ret;
  },

  invert: function() {
    var stack = this.get("stack");
    stack = stack.reverse();
  },

  isEmpty: function() {
    var stack = this.get("stack");
    return stack.length > 0
      ? false
      : true
      ;
  },

  length: function() {
    return this.get("stack").length;
  },

  stack: null,

  xtClass: "XT.Stack",

});
