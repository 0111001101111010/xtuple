
// require some core modules
var UTIL    = require("util");
var PATH    = require("path");
var FS      = require("fs");


/** @private */
XT.Tools.fs = {
  
  /** @public */
  normalize: function() {
    var args = Array.prototype.slice.call(arguments),
      base = args.shift();
    base = base.replace(/^(\w)/, "./$1").replace(/(\w$/, "$1/");
    for(var i=0, len=args.length; i<len; ++i)
      base += args[ i ].replace(/^\/+/, "").replace(/(\w)$/, "$1/");
      return base.substring(0, base.length-1);
  },

  /** @public */
  readDir: function(path, types) {
    var files, useTypes = false;
    path = PATH.normalize(path);
    // if(!path.match(/(.*)+\/$/)) path = "{0}/".format(path);
    if(types instanceof Array) {
      useTypes = true;
      XT.Tools.each(types, function(idx, pattern) {
        types[ idx ] = new RegExp("{0}$".format(pattern), "g");
      });
    }
    if(!this.validate(path, "dir")) {
      XT.puts("ERROR HOLDER: COULD NOT VALIDATE DIR");
    } else {
      files = FS.readdirSync(path);
      if(useTypes) {
        // return files.matches(types).prepend(path);           
        return XT.Tools.prepend(XT.Tools.matches(files, types), path);
      } else { return files; }
    }
  },

  /** @public */
  fetchDir: function(path, types) {
    var files = this.readDir(path, types), assoc = {};
    for(var i=0, len=files.length; i<len; ++i)
      assoc[ files[ i ] ] = FS.readFileSync(files[ i ], "utf-8")
    return assoc;
  },

  /** @public */
  fetchFile: function(path, file) {
    var file = PATH.join(path, file);
    file = FS.readFileSync(file, "utf-8");
    return file;
  },

  /** @public */
  fullStruct: function(path) {
  },

  /** @public */
  validate: function(path, type) {
    try {
      var stat = FS.statSync(path);
      if(type) {
        switch(type) {
          case "file":
            return stat.isFile();
            break;
          case "dir":
            return stat.isDirectory();
            break;
          default:
            return false;
            break;
        }
      } else { return true; }
    } catch(e) {
      XT.puts("ERROR HOLDER: {0}".format(e));
    }
  },
};

