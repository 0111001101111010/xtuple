
//.................................................
// STANDALONE TEST FOR METASQL INTERPRETER
// FOR DEVELOPMENT ONLY (at this time)


var PSQL    = require("psql");
var PATH    = require("path");
var UTIL    = require("util");

require("tools");
require("store");

// UNCOMMENT THESE LINES IF TESTING AS STANDALONE
// XT.DEVC = new PSQL.connect("pgsql://cole:cole@dev.xtuple.com:7000/dev");
// 
// process.on("exit", function() {
//   XT.DEVC.close();
// });


//..............................................
// INCOMPLETE AS OF 8/16/2011

/** @private
  Helper class designed to fetch MetaSQL from the database or handle
  local file or string appropriately (i.e. however the MetaSQL comes
  we should be able to handle it from here).
*/
XT.MetaSQLHandler = XT.Object.extend({

  /** @private */
  init: function() {

    // listeners
    this.on("register", this.register);
    this.on("setupDone", this.ready);

    // run setup routine (collecting metasql...)
    this.setup();
  },

  /** @private */
  fetch: function(group, name) {
    var entry = "{0}.{1}".format(group, name);
    var uuid = this.get(entry);
    if(false === uuid) {
      XT.throw(new XT.FATAL({ message: "Request for unknown MetaSQL: {0}".format(
        entry) }));
    } else { return this.get("cache").fetch(uuid); }
  },

  /** @private */
  ready: function() {
    this.set("isReady", true);
    XT.puts("done");
    process.emit("OK_GO");
  },

  /** @private */
  register: function(xtMetaSql) {

    // grab the stack so we can pop an element...
    var stack = this.get("fetchStack");

    // grab the meta data
    var group = xtMetaSql.get("group"),
      name = xtMetaSql.get("name");
    
    // the object to register based on concatenated strings...
    var entry = "{0}.{1}".format(group, name);

    // the local entry will be a uuid for the cached element
    var uuid = this.get("cache").insert(xtMetaSql);

    // now set the name to the uuid for its true storage...
    this.set(entry, uuid);

    // pop the stack and test for if we're done
    stack.pop(); if(stack.isEmpty()) this.emit("setupDone");
  },

  /** @private */
  setup: function() {

    // the query to run...
    var sql = XT.MetaSQLHandler.FETCH_METASQL_ALL_SQL, self = this;

    XT.puts("Setting up the MetaSQL handler and registering components...", true);

    //.............................................
    // DEVELOPMENT ONLY

    XT.DEVC.query(sql, function(err, res) {
      
      // if there was an error here, we want to go ahead and throw a fatal
      // so it can be dealt with, odds are, if we can't do it now, we
      // can't do it later either
      if(err) { XT.throw(new XT.FATAL({ message: err })); }

      self.set("fetchStack", XT.Stack.create({ stack: res.length }));

      // iterate over the response and create the new XT.MetaSQL objects
      // and have them register themselves
      XT.Tools.each(res, function(idx, row) {

        // create the new XT.MetaSQL object
        var xtMetaSql = XT.MetaSQL.create({

          // set the ultimate row value for it
          rowEntry: row,

          // set the reference to the handler
          handler: self,
        });
      });

    });
  },

  /** @private */
  cache: XT.Cache,

  /** @private */
  xtClass: "XT.MetaSQLHandler",

});

XT.MetaSQLHandler.FETCH_METASQL_SQL = "" +
  "SELECT metasql_query " +
  "FROM metasql " +
  "WHERE ((metasql_group='{group}') AND (metasql_name='{name}')) " +
  "ORDER BY metasql_grade DESC " +
  "LIMIT 1";

XT.MetaSQLHandler.FETCH_METASQL_ALL_SQL = "" +
  "SELECT DISTINCT ON(metasql_group, metasql_name) * " +
  "FROM metasql " +
  "ORDER BY metasql_group, metasql_name, metasql_grade DESC";


XT.MetaSQL = XT.Object.extend({

  /** @private */
  init: function() {

    this.on("isSanitized", this.register);

    // sanitize the MetaSQL by removing ALL comments throughout
    // the script and putting all those comments in an array separately
    this.sanitize();
  },

  /** @private */
  sanitize: function() {

    // we only want to sanitize once
    if(this.get("isSanitized")) return true;


    // grab the row-data for the entry in postgres
    // and for convenience push some of the data
    // to the object
    var objSource = this.get("rowEntry");

    this.set("id",      objSource.metasql_id);
    this.set("source",  objSource.metasql_query);
    this.set("name",    objSource.metasql_name);
    this.set("group",   objSource.metasql_group);
    this.set("grade",   objSource.metasql_grade);


    // grab the source, split into lines, iterate over lines, remove
    // comments and insert them into another array, also note, since
    // we're removing lines from the original lines array,
    // we're temporarily shoving the lines to keep into a new array
    // for simplicity (the lines array should be immutable)
    var source = this.get("source"),
      lines = source.split("\n"), comments = [], keep = [], self = this;
    
    // begin the iteration 
    XT.Tools.each(lines, function(idx, line) {

      // if it matches the simple regex
      if(line.match(/^\s*--/g)) {
        comments.push(line); 
      } else { keep.push(line); }
    });

    // merge `keep` array back into single string since the parsing is
    // not done line-by-line
    keep = keep.join("");

    // set both values on the object for later reference
    this.set("source", keep);
    this.set("comments", comments);

    // make sure to set the isSanitized flag...
    this.set("isSanitized", true);
  },

  /** @private */
  register: function() {
    var handler = this.get("handler");
    handler.emit("register", this);
    this.cleanup();
  },

  /** @private */
  cleanup: function() {
    this.delete("rowEntry");
    this.delete("handler");
  },

  /** @private */
  xtClass: "XT.MetaSQL",

});


XT.MetaSQLBlock = XT.Object.extend({

  /** @private */
  init: function() {},

  /** @private */
  xtClass: "XT.MetaSQLBlock",

});

process.on("CONNECTION_AVAILABLE", function() {
  XT.MetaSQLHandler = XT.MetaSQLHandler.create();
});
