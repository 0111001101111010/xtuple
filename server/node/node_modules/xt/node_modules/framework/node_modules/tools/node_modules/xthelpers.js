
// require core modules
var UTIL    = require("util");
var PATH    = require("path");

/** @public */
XT.Tools.keys = function(enumObj) {
  if(false === (enumObj instanceof Object)) return false;
  if(enumObj instanceof Array) return false;
  var keys = [];
  for(property in enumObj) {
    if(enumObj.hasOwnProperty(property)) {
      if(XT.Object.notHidden(enumObj, property)) {
        keys.push(property);
      }
    }
  }
  return keys.length > 0
    ? keys
    : false
    ;
};

/** @public */
XT.Tools.values = function(enumObj, specProperty) {
  if(enumObj instanceof Object) {
    if(enumObj instanceof Array) return enumObj;
    var values = [];
    for(property in enumObj)
      if(enumObj.hasOwnProperty(property) &&
        XT.Object.notHidden(enumObj, property))
          if(specProperty) {
            values.push(enumObj[ property ][ specProperty ]);
          } else { values.push(enumObj[ property ]) };
    return values.length > 0
      ? values
      : false
      ;
  } else { return false; }
};



/** @private */
XT.Tools.generateRegEx = function(string) {
  var relation = this.get("atlas.name"), 
    regex = new RegExp("{{0}.{1}}".format(relation, string), "g");
  return { field: string, regex: regex }; 
};

/** @public */
XT.Tools.in = function(enumObj, key) {
  if(enumObj instanceof Array) {
    for(var i=0, len=enumObj.length; i<len; ++i) {
      if(enumObj[ i ] == key) { return true; }
    }
    return false; 
  } else if(enumObj instanceof Object) {
    return XT.Tools.in(XT.Tools.keys(enumObj), key);
  } else { return false; }
};

/** @public */
XT.Tools.each = function(enumObj, callback) {
  if(false === (callback instanceof Function)) return false;
  if(enumObj instanceof Array) {
    for(var i=0, len=enumObj.length; i<len; ++i)
      if(false === callback(i, enumObj[ i ]))
        return;
  } else if(enumObj instanceof Object) {
    for(property in enumObj)
      if(enumObj.hasOwnProperty(property) && 
        XT.Object.notHidden(enumObj, property))
        if(false === callback(property, enumObj[ property ]))
          return false;
    return true;
  } else { return false; }
};

/** @public */
XT.Tools.clone = function(enumObj) {
  var obj;
  if(enumObj instanceof Object) {
    if(enumObj instanceof Array) {
      obj = [];
      for(var i=0, len=enumObj.length; i<len; ++i) {
        obj.push(XT.Tools.clone(enumObj[ i ]));
      }
    } else if(enumObj instanceof Function) {
      obj = enumObj;
    } else if(enumObj instanceof RegExp) {
      return enumObj;
    } else {
      obj = {};
      for(property in enumObj) {
        if(!enumObj.hasOwnProperty(property)) continue;
        obj[ property ] = XT.Tools.clone(enumObj[ property ]);
      }
    }
  } else { return enumObj; }
  return obj;
};

/** @public */
XT.Tools.matches = function(enumObj, patterns, useKeys) {
  if(false === (enumObj instanceof Object)) return false;
  var matches = [], keys;
  if(useKeys) {
    keys = XT.Tools.keys(enumObj);
  } else { keys = XT.Tools.values(enumObj); }
  XT.Tools.each(keys, function(idx, value) {
    XT.Tools.each(patterns, function(idx, pattern) {
      if(pattern instanceof RegExp) {
        if(value.match(pattern))
          matches.push(value);
      } else if(value.indexOf(pattern) !== -1) {
        matches.push(value);
      }
    });
  });
  return matches.length > 0
    ? matches
    : false
    ;
};

/** @public */
XT.Tools.prepend = function(enumObj, prefix) {
  XT.Tools.each(enumObj, function(idx, value) {
    enumObj[ idx ] = prefix + value;
  });
  return enumObj;
};

/** @private */
// XT.Tools.parseRequestUrl = function(url) {
//   var ret = {}, parts = url.match(/^\//) !== null
//     ? url.substring(1).split("/")
//     : url.split("/")
//     ;
//   ret.action = parts[ 0 ];
//   if(parts.length >= 2) {
//     ret.type = parts[ 1 ];
//     // ret.model = parts[ 2 ] || "default";
//   } else { return false; }
//   // ret.concatenated = "{0}.{1}".format(ret.type, ret.model);
//   // XT.puts("RETURNING PARSED URL OBJECT: {0}".format(UTIL.inspect(ret)));
//   return ret;
// };


/** @private */
XT.Tools.findIn = function(queryResponse, key, value) {
  for(var i=0, len=queryResponse.length; i<len; ++i)
    if(queryResponse[ i ][ key ] === value)
      return queryResponse[ i ];
  return false;
};

/** @private */
// XT.Tools.prepareResponse = function(resultSet, xtQuery) {
// 
//   var info = resultSet.info;
//   
//   var response = info.response,
//     // payLoad = JSON.stringify(data);
//     payLoad = UTIL.inspect(resultSet.results, true, 10);
//   response.setHeader("Content-Type", "application/json");
//   response.write(payLoad);
//   response.end();
// 
//   xtQuery.delete("resultSet");
// 
// 
// };

/** @private */
XT.Tools.publishRequest = function(xtResponse, router) {
  var str = ("{0}: Received Request\n"
    + "URL: {1}\n"
    + "METHOD: {2}\n"
    + "CONTENT-TYPE: {3}\n"
    + "CLIENT: {4}\n")
  .format(
    router.get("server.name"),
    xtResponse.url,
    xtResponse.requestMethod,
    xtResponse.contentType,
    xtResponse.client.remoteAddress
  );
  str += ("PAYLOAD: {0}\n").format(XT.inspect(xtResponse.payloadIn, true, true) || "");
  XT.puts(str);
};

XT.Tools.createPsqlString = function(parts) {
  var str = "pgsql://";
  str += parts.user + ":" + parts.password + "@"; 
  str += parts.host + ":" + parts.port + "/" + parts.database;
  return str;
};

/** @public */
XT.Tools.replace = function() {
  var args = Array.prototype.slice.call(arguments);
  var base = args.shift();
  var opts = args.shift();
  var shouldCleanup = args.length > 0 ? args.shift() : true;
  var cleanup = /{(\w+)}/g;
  XT.Tools.each(opts, function(idx, KVO) {
    var regex = KVO.regex, value = KVO.value;
    base = base.replace(regex, value);
  });
  if(shouldCleanup) base = base.replace(cleanup, "");
  return base;
};

/** @public */
XT.Tools.invert = function(enumObj) {
  var inverted = {};
  XT.Tools.each(enumObj, function(key, value) {
    if(value && !(value instanceof Object))
      inverted[ value ] = key;
  });
  return inverted;
};
