
// require some core modules
var UTIL    = require("util");
var PATH    = require("path");

// load into module namespace from above
require("tools");
require("exception");
require("store");
require("functor");

XT.CommitFunctor = XT.Functor.create({

  /** @public */
  exec: function(xtResponse, changeset) {

    // @todo Security and sanity-checking should take place HERE when it
    //  is available.
    // XT.puts(typeof changeset);
    // XT.inspect(changeset);

    // grab the changeset
    try {
      changeset = JSON.parse(changeset);
    } catch(e) { XT.throw(new XT.FATAL({ message: e, stack: e.stack })); }

    // need to determine how many "replies" the xtResponse should wait
    // on before letting the client know it was done
    // this (at this point) the number of entries for each type summed

    // maybe there is an easier way?

    var stackSize = 0, self = this;

    // HATE iterating over list BEFORE iterating over it........
    XT.Tools.each(changeset.sc_types, function(idx, type) {
      var type = changeset[ type ];
      stackSize += type.deleted.length;
      stackSize += type.updated.length;
      stackSize += type.created.length;
    });

    // XT.puts("SHOULD BE WAITING ON {0} RETURNS".format(stackSize));

    xtResponse.set("noDataStack", XT.Stack.create({ stack: stackSize }));

    XT.Tools.each(changeset.sc_types, function(idx, type) {

      // // grab the record type
      // var type = changeset.sc_types[ 0 ];

      // grab the query for the type and then determine the type of sql needed
      // xtResponse.query = XT.Store.fetchQuery(type);
      var info = {};
      info.query = XT.Store.fetchQuery(type);

      // set the sql type
      info.SQLTYPE = (function(payload) {
        var which;
        XT.Tools.each(payload, function(action, on) {
          if(on.length > 0) {
            which = action;
            return false;
          }
        });
        return which;
      })(changeset[ type ]);

      // reduce the payloadIn to match the needed form
      var reduce = {};
      reduce[ type ] = changeset[ type ][ info.SQLTYPE ][ 0 ];
      info.payloadIn = reduce;

      // raise the SQLTYPE to uppercase
      info.SQLTYPE = info.SQLTYPE.toUpperCase();

      // XT.puts("SQLTYPE: {0}".format(xtResponse.SQLTYPE));

      // emit the action
      self.emit("action", xtResponse, info);
    });

  },
  
  /** @private */
  action: function(xtResponse, info) {

    if(info) {
      info.query.emit("exec", xtResponse, info); 
    } else { xtResponse.query.emit("exec", xtResponse); }

  },

  /** @private */
  xtClass: "XT.CommitFunctor",

});

process.emit("loadedFunctor", XT.CommitFunctor);
