
// require core modules
var UTIL    = require("util");
var PATH    = require("path");

// load into module namespace
require("framework");

XT.Record = XT.Object.extend({

  init: function() {

    var self = this;

    // setup listeners
    this.on("retrieve", this.retrieve);
    this.on("commit", this.commit);
    this.on("runQuery", this.query);

    if(this.toManiesNotReady) {

      XT.puts("toManiesNotReady was true: {0}".format(this.toManiesNotReady));

     var entries = this.ADDITIONAL_SELECT_ENTRIES, count = XT.Tools.keys(entries).length;
      
      if(count > 0) {

        this.on("additionalEntriesReady", function() {
          try {
            var values = XT.Tools.values(self.ADDITIONAL_SELECT_ENTRIES, "sql");
            var types = XT.Tools.values(self.ADDITIONAL_SELECT_ENTRIES, "recordType");
            this.set("types", types);
          } catch(e) { XT.throw(new XT.FATAL({ message: e })); }
          var str = ", {0}".format(values.join(", "));
          self.SELECT = XT.Tools.replace(self.SELECT, [
            { value: str, regex: /{tomany}/ } ], false);
          self.__proto__.toManiesNotReady = false;
        });

        XT.Tools.each(entries, function(fieldName, fieldObj) {
          XT.inspect(entries);
          self[ fieldName ] = XT.Tools.clone(fieldObj);
          self[ fieldName ]();
          --count; if(count === 0) self.emit("additionalEntriesReady");
        });
      }

    }

  },

  getFieldName: function(colName) {
    return this.get("map.columns")[ colName ] || false;
  },

  getColumnName: function(fieldName) {
    return this.get("map.fields")[ fieldName ] || false;
  },

  prepare: function(info) {

    // @todo VALIDATION PLUGIN?

    try {

      // try to parse the JSON payload...
      info.payLoad = JSON.parse(info.payLoad);

      // determine course based on action requested in URL
      this.emit(info.action, info);
    } catch(e) { XT.throw(XT.E205, info.payLoad, info.response); }

  },

  commit: function(info) {

  },

  retrieve: function(info) {

    // retrieve means we want to pull data via SELECT query
    // we can build the top-level query by calling the
    // buildSelectFrom helper method
    var extracted = info.payLoad[ this.get("xtClass") ] || null;

    // if there was no payload data we can't do anything
    if(!extracted) XT.throw(XT.E206, info.payLoad, info.response);

    // grab the top level query...
    info.query = XT.Record.buildSelectFrom.call(this, extracted);

    // emit the runQuery event
    this.emit("runQuery", info);
  },

  query: function(info) {
    
    var sql = info.query, self = this; 

    // XT.puts("\nRunning Query:\n{0}\n".format(sql));

    //...........................................
    // during development ONLY...ALPHA 0.0.1

    if(!XT.DEVC) XT.throw(new XT.FATAL({ message: "COULD NOT FIND DEV PSQL CONNECTION!" }));

    XT.DEVC.query(sql, function(err, res, tx) {

      if(err) { XT.throw(XT.E207, "{0}\n{1}".format(err, sql), info.response); }

      else {

        // try {

          var arrayFields = XT.Tools.keys(self.ADDITIONAL_SELECT_ENTRIES);

          XT.inspect(arrayFields);

          // @todo Hack to take any of the TO MANY array subquery responses and
          //    put them in a form that JSON will parse as array not string with
          //    {} at both ends and also converts them to digit
          XT.Tools.each(res, function(idx, row) {
            XT.Tools.each(arrayFields, function(idx, field) {
              if(row[ field ].length < 3) {
                row[ field ] = [];
              } else {
                var tmp = row[ field ].substring(1, row[ field ].length-2).split(",");
                XT.Tools.each(tmp, function(idx, guidVal) {
                  tmp[ idx ] = Number(guidVal);
                });
                row[ field ] = tmp;
              }
            });
          });

          // start up a reference to the object that will eventually be parsed
          // into the JSON response
          var json = { sc_types: [].concat(self.get("types")) };

          // add this XT.Record class to the sc_types array
          json.sc_types.push(self.get("xtClass"));

          json[ self.get("xtClass") ] = res;

          json = JSON.stringify(json);
          info.response.writeHead(200, { "Content-Type": "application/json" });
          info.response.write(json);
          info.response.end();
        // } catch(e) { XT.throw(XT.E208, res, info.response); }
      }

    });
  },

  xtClass: "XT.Record",
  
});

XT.RecordHelpers = {

  /** @private
    @param {XT.Record} an instance of the referring record
    @param {Object} hash of known properties from which to build
  */
  toMany: function(atlas, hash) {
    var regex = /{field}/,
    from, inverse, static;
    from = hash.from, inverse = hash.inverse,
      static = hash.static || false, from = atlas.getColumnName(from),
      dataHash = {};
    dataHash[ inverse ] = from;

    // @todo Synchronous execution...should this change?
    var select = XT.Record.buildSelectFrom.call(this, dataHash, [ static ], true, hash.field);
    atlas.ADDITIONAL_SELECT_ENTRIES[ hash.field ] = { recordType: this.prototype.xtClass, sql: select };
  },

  or: function(hash) { },
  
  and: function(hash) { },

  toOne: function(recType, hash) { },

};

XT.__extend(XT.Record, XT.RecordHelpers);

//.....................................
// record helper functions

XT.Record.static = function(hash) {
  var keys = XT.Tools.keys(hash),
    parts = [];
  XT.Tools.each(keys, function(idx, key) {
    parts.push("{0}={1}".format(key, hash[ key ]));
  });
  return parts.join(" AND ");
};

XT.Record.buildQueries = function() {
  var proto = this.prototype;
  XT.Record.buildSelect.call(proto);
  XT.Record.buildUpdate.call(proto);
  XT.Record.buildInsert.call(proto);
};

XT.Record.buildSelect = function() {
  var fields = this.fields, self = this, indirectColumns = {},
    directColumns = [], template = XT.Record.SELECT_TEMPLATE,
    guidTemplate = XT.Record.SELECT_GUID_TEMPLATE, table = this.table, schema = this.schema,
    from = XT.Record.formatFullTableName(schema, table), guidColumn;
  XT.Tools.each(fields, function(field, fieldDefinition) {
    if(fieldDefinition.column) {
      var column = fieldDefinition.column;
      if(field == "guid") guidColumn = column;
      directColumns.push(XT.Record.formatColumnSelectEntry(field, column));
    } else if(fieldDefinition instanceof Function) {
      indirectColumns[ field ] = fieldDefinition;
    }
  });
  directColumns = directColumns.join(", ");
  this.ADDITIONAL_SELECT_ENTRIES = indirectColumns;
  this.SELECT = XT.Tools.replace(template, [
    { value: directColumns, regex: /{columns}/ },
    { value: from, regex: /{table}/ } ],
    false);
  this.SELECT_GUID = XT.Tools.replace(guidTemplate, [
    { value: "{0} AS \"guid\"".format(guidColumn),
      regex: /{column}/ },
    { value: from, regex: /{table}/ } ], false);
};

XT.Record.buildUpdate = function() {
  var fields = this.fields, self = this,
    columns = [], values = {},
    template = XT.Record.UPDATE_TEMPLATE,
    table = this.table, schema = this.schema,
    from = XT.Record.formatFullTableName(schema, table);
  XT.Tools.each(fields, function(field, fieldDefinition) {
    if(fieldDefinition.column) {
      var column = fieldDefinition.column;
      values[ field ] = { value: null, 
        regexp: new RegExp("{{0}}".format(field)) };
      columns.push("{0}={{1}}".format(column, field));
    }
  });
  var sets = "SET {0}".format(columns.join(", "));
  this.UPDATE = XT.Tools.replace(template, [
    { value: sets, regex: /{sets}/ },
    { value: from, regex: /{table}/ } ],
    false);
  this.UPDATE_TEMPLATE_KEYS = values;
};

XT.Record.buildDelete = function() {
  var fields = this.fields, self = this,
    directColumns = [], template = XT.Record.SELECT_TEMPLATE,
    table = this.table, schema = this.schema,
    from = XT.Record.formatFullTableName(schema, table);
};

XT.Record.buildInsert = function() {
  var fields = this.fields, self = this,
    directColumns = [], values = [], insertKeys = {},
    template = XT.Record.INSERT_TEMPLATE,
    table = this.table, schema = this.schema,
    from = XT.Record.formatFullTableName(schema, table);
  XT.Tools.each(fields, function(field, fieldDefinition) {
    if(fieldDefinition.column) {
      var column = fieldDefinition.column;
      var fieldKey = "{{0}}".format(field);
      directColumns.push(column);
      values.push(fieldKey);
      insertKeys[ field ] = { value: null, regex: new RegExp(fieldKey) };
    }
  });
  values = "VALUES({0})".format(values.join(", "));
  directColumns = "({0})".format(directColumns.join(", "));
  this.INSERT = XT.Tools.replace(template, [
    { value: values, regex: /{values}/ },
    { value: from, regex: /{table}/ },
    { value: directColumns, regex: /{columns}/ } ],
    false);
  this.INSERT_TEMPLATE_KEYS = insertKeys;
};

XT.Record.formatColumnSelectEntry = function(field, column) {
  return "{0} AS \"{1}\"".format(column, field);
};

XT.Record.formatFullTableName = function(schema, table) {
  return "{0}.{1}".format(schema, table);
};

XT.Record.buildRecordMap = function() {
  var fields = this.prototype.fields;
  var columns = {}, flatFields = {};
  XT.Tools.each(fields, function(fieldName, fieldObj) {
    var col = fieldObj.column || false;
    if(!col) return;
    columns[ col ] = fieldName;
    flatFields[ fieldName ] = col;
  });
  this.prototype.map = {};
  this.prototype.map.columns = columns;
  this.prototype.map.fields = flatFields;
};

XT.Record.buildSelectFrom = function(hash, statics, justGuid, field) {
  var select = justGuid
    ? XT.Tools.replace(this.SELECT_GUID || this.prototype.SELECT_GUID,
        [ { value: field, regex: /{field}/ } ], false)
    : this.SELECT || this.prototype.SELECT
    ;
    var regex = /{where}/g,
    where = XT.Record.buildWhere.call(this, hash, statics);
  select = XT.Tools.replace(select, [ { value: where, regex: regex } ], true);
  return select;
};

XT.Record.buildWhere = function(hash, statics) {
  self = this.fields
    ? this
    : this.prototype
    ;
  var where = [];
  XT.Tools.each(hash, function(field, value) {
    if(value instanceof Array) {
      XT.Tools.each(value, function(idx, altValue) {
        where.push("{0}={1}".format(self.fields[ field ].column, altValue));
      });
      where = [ "({0})".format(where.join(" OR ")) ];
    } else { where.push("{0}={1}".format(self.fields[ field ].column, value)); }
  });
  if(statics && statics.length > 0) where = where.concat(statics);
  where = where.join(" AND ");
  return "WHERE {0}".format(where);
};

XT.Record.SELECT_TEMPLATE = "SELECT {columns} {tomany} FROM {table} {where}";
XT.Record.SELECT_GUID_TEMPLATE = "array(SELECT {column} FROM {table} {where}) AS \"{field}\"";
XT.Record.WHERE = "WHERE {0}";
XT.Record.INSERT_TEMPLATE = "INSERT INTO {table} {columns} {values}";
XT.Record.UPDATE_TEMPLATE = "UPDATE {table} {sets} {where}";
XT.Record.DELETE_TEMPLATE = "DELETE FROM ONLY {table} {where}";


XT.Record.prototype.toManiesNotReady = true;
