
// load into module namespace from above
require("tools");
require("exception");
require("security");

// load into module namespace from level
require("psql_query_builder");

XT.PSQLQuery = XT.Object.extend({

  /** @private */
  init: function() {
    this.on("exec", this.exec);
  },

  //....................................
  // methods

  /** @private
    DO NOT CALL THIS METHOD. But, if for some reason you
    need to EMIT "exec" ON THE QUERY do NOT call it directly.
  */
  exec: function(xtResponse, info) {

    if(xtResponse.SQLTYPE == "SELECT" || xtResponse.SQLTYPE == "SELECTALL") {
      this.execSelect(xtResponse);
    } else if(info && info.SQLTYPE == "UPDATED") {
      this.execUpdate(xtResponse, info);
    } else if(info && (info.SQLTYPE == "INSERT" || info.SQLTYPE == "CREATED")) {
      this.execInsert(xtResponse, info);
    // } else { xtResponse.end("CAN'T DO THAT YET => {0}".format(xtResponse.SQLTYPE)); }
    } else { XT.throw(new XT.FATAL({ message: "CAN'T COMPLETE ACTION REQUESTED: {0}".format(xtResponse.SQLTYPE) })); }
  },

  /** @private */
  execInsert: function(xtResponse, info) {

    // xtResponse.set("nonRecord");

    var sql = this.INSERT, values = info.payloadIn[ this.get("sctype") ],
      regex = XT.Tools.clone(sql.regex);

    XT.Tools.each(values, function(field, value) {
      var _value = (function(value) {
        if(typeof value === "object") {
          return null;
        } else {
          return isNaN(value)
            ? "'{0}'".format(value)
            : value
            ;
        }
      })(value);
      if(_value)
        if(regex[ field ]) regex[ field ].value = _value;
    });

    sql = XT.Tools.replace(sql.template, regex, false);

    XT.puts("WANTED TO USE: {0}".format(sql));

    //........................................
    // DEVELOPMENT ONLY (PRE SESSION)

    XT.DEVC.query(sql, function(err, res, tx) {
      
      // if error, throw fatal for now
      if(err) { XT.throw(new XT.FATAL({ message: "{0}\n{1}".format(err, sql) })); }

      // we're done, no errors, just...end?
      xtResponse.noDataReturn();

    });

  },

  /** @private */
  execUpdate: function(xtResponse, info) {

    // its not a record response, we want it to go back clean
    // UNLESS there is an error in which case it gets set back to
    // application/json automatically based on the send method used
    xtResponse.set("nonRecord");

    // grab the SQL
    var sql = this.UPDATE, values = info.payloadIn[ this.get("sctype") ],
      regex = XT.Tools.clone(sql.regex);

    // for each of the values that are present write them into the regex piece
    XT.Tools.each(values, function(field, value) {
      var _value = (function(value) {
        if(typeof value === "object") {
          return null; 
        } else { 
          return isNaN(value)
            ? "'{0}'".format(value)
            : value
            ;
        }
      })(value);
      if(_value)
        if(regex[ field ]) regex[ field ].value = _value;
    });

    // fill in the template
    sql = XT.Tools.replace(sql.template, regex, false);

    // fill in where clause
    sql = XT.PSQLQueryBuilder.buildWhere.call(this, info, sql);

    // reference to self
    var self = this;

    // xtResponse.set("nonRecord").sendJson({ error: 1, code: XT.E1000.code });

    //........................................
    // DEVELOPMENT ONLY (PRE SESSION)

    XT.DEVC.query(sql, function(err, res, tx) {
      
      // if error, throw fatal for now
      if(err) { XT.throw(new XT.FATAL({ message: "{0}\n{1}".format(err, sql) })); }

      // we're done, no errors, just...end?
      xtResponse.noDataReturn();

    });

  },

  /** @private */
  execSelect: function(xtResponse) {

    // this is the top level query
    // if this query object has relations it will need to fire
    // post-complete it needs to set those up in an auto-running
    // stack on the xtResponse object so it will chain them
    if(this.hasRelations) {

      // @note This is only doing this for toMany as of now...
      var stack = XT.Stack.create();

      XT.Tools.each(this.get("toMany"), function(field, toManyConstructor) {
        stack.push(toManyConstructor);
      });

      // set the stack on the xtResponse object, it has auto setup
      // for the event when the stack is set
      xtResponse.set("relationStack", stack);

    } else { xtResponse.set("relationStack", XT.Stack.create()); }

    // grab the actual sql
    var sql = this.SELECT[ xtResponse.SQLTYPEFORM ];

    // XT.puts("\nUSING {0}\n\nBECAUSE SQLTYPEFORM WAS `{1}`".format(
    //  sql, xtResponse.SQLTYPEFORM));

    // if needed, create the where statement
    if(xtResponse.SQLTYPEFORM == "template")
      sql = XT.PSQLQueryBuilder.buildWhere.call(this, xtResponse, sql);

    // set reference to self...
    var self = this;

    // fire the query

    //........................................
    // DEVELOPMENT ONLY (PRE SESSION)

    XT.DEVC.query(sql, function(err, res, tx) {
      
      // if error, throw fatal for now
      if(err) { XT.throw(new XT.FATAL({ message: "{0}\n{1}".format(err, sql) })); }

      // XT.puts("QUERY RESPONSE FROM TOP-LEVEL: {0}".format(
      //   XT.inspect(res, true, true)));

      // @todo Need to setup a conversion process/hook for ALL data types
      //    or arbitrary translations...

      // need to manually convert PostgreSQL arrays (strings with {}) into
      // array objects in JavaScript
      var toMany = self.get("toMany");
      if(toMany) {
        var keys = XT.Tools.keys(toMany);
        XT.Tools.each(keys, function(idx, key) {
          XT.Tools.each(res, function(_idx, row) {
            row[ key ] = XT.PSQLQueryBuilder.unwrap(row[ key ]);
          });
        });
      }

      // since this is the top level query set the response as
      // the xtResponse's resultSet for subsequent queries to look at
      xtResponse.set("resultSet", res);

      // all done...xtResponse will take care of the rest

    });

  },

  //.....................................
  // fields as supplied by query builder

  /** @private
    Fields to postgres table mapping.
  */
  fields: null,

  /** @private
    Any toOne relation's uuid's and field they belong to.
  */
  toOne: null,

  /** @private
    Any toMany relation's uuid's and field they belong to.
  */
  toMany: null,

  /** @private
    The table this record's query is associated with.
  */
  table: null,

  /** @private
    The schema that the table resides in.
  */
  schema: null,

  /** @private
    The Sproutcore record name. Usually matches the XT.Record class
    but just in case...
  */
  sctype: null,

  /** @private
    The record definition.
  */
  record: null,

  /** @private
    The original XT.Record class name.
    purps
  */
  type: null,

  /** @private */
  xtClass: "XT.PSQLQuery",

});


//.....................................................
// special subquery types for relations

XT.PSQLtoManyQuery = XT.Object.extend({
  
  /** @private */
  init: function() {
    this.on("exec", this.exec);
  },

  /** @private */
  exec: function(guid, callback) {

    // just need to setup the sql, run it, and return the
    // result to the callback 
    var sql = XT.PSQLQueryBuilder.buildWhere.call(this, guid, this.get("sql"));
    
    // execute it...
    
    //...................................
    // DEVELOPMENT ONLY (PRE SESSION)
    
    XT.DEVC.query(sql, function(err, res, tx) {
      
      // on error...throw fatal for now
      if(err) { XT.throw(new XT.FATAL({ message: "SUBQUERY FAILED: {0}".format(err) })); }

      // just call the callback with the result
      callback(res);
    });
  },

  /** @private */
  sql: null,

  /** @private */
  fields: null,

  /** @private */
  xtClass: "XT.PSQLtoManyQuery",

});
