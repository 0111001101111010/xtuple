
// load into module namespace from above
require("tools");
require("exception");
require("security");

// load into module namespace from level
require("psql_query");

XT.PSQLQueryBuilder = XT.Object.create({

  /** @private */
  init: function() {

    // register some listeners
    this.on("buildSelect", this.buildSelect);
    this.on("buildInsert", this.buildInsert);
    this.on("buildUpdate", this.buildUpdate);
    this.on("buildDelete", this.buildDelete);
    this.on("buildToMany", this.buildToMany);
    this.on("buildFinalize", this.buildFinalize);
  },

  //............................................
  // public methods and accessors

  /** @public */
  build: function(xtRecordType, xtRecordDef) {
  
    var proto = xtRecordDef.prototype.definition;

    // need to extract the data from the record and then
    // discard it (for now this will leave the record essentially
    // an empty shell but thats ok...
    var hash        = {};
    hash.fields     = proto.fields;
    hash.toOne      = proto.toOne || null;
    hash.toMany     = proto.toMany || null;
    hash.table      = proto.table;
    hash.schema     = proto.schema;
    hash.sctype     = proto.sctype || xtRecordType;
    hash.sequence   = proto.sequence || null;
    hash.record     = xtRecordDef;
    hash.type       = xtRecordType;

    // remove the definition...
    delete xtRecordDef.prototype.definition;

    // place the sequence back on the prototype
    xtRecordDef.prototype.sequence = hash.sequence;

    // get it all started
    this.emit("buildSelect", hash.fields, hash.schema, hash.table, hash);
  },

  /** @private */
  buildFinalize: function(fields, columns, sql, hash) {

    // reattach the fields and columns to the record def prototype
    // so the convenience retrieval methods will work on instances
    hash.record.prototype.fields = fields;
    hash.record.prototype.columns = columns;

    // the sql object has the correct form for INSERT, UPDATE,
    // DELETE, and SELECT queries that we need to add to the
    // query hash
    XT.Tools.each(sql, function(which, template) {
      hash[ which ] = template;
    });

    XT.Driver.emit("queryBuilt", XT.PSQLQuery.create(hash));

  },

  /** @private */
  buildSelect: function(fields, schema, table, hash) {

    // the un-fun part of setting these up are the crappy
    // text operations from inlined templates...yuck

    // fix the table to the schema
    table = "{0}.{1}".format(schema, table);

    //......................................
    // BEGIN SELECT

    // format the select sql for the columns
    var selectColumns = (function(fields) {
      var cols = [];
      XT.Tools.each(fields, function(field, column) {
        cols.push("{0} AS \"{1}\"".format(column, field));
      });
      return cols.join(", ");
    })(fields);

    // the rest of the SELECT
    var SELECT = XT.Tools.replace(XT.PSQLQueryBuilder.TEMPLATES.SELECT, [
      { value: selectColumns, regex: /{columns}/ },
      { value: table, regex: /{table}/ } ], false);

    // the select ALL case
    var SELECTALL = XT.Tools.replace(XT.PSQLQueryBuilder.TEMPLATES.SELECTALL, [
      { value: selectColumns, regex: /{columns}/ },
      { value: table, regex: /{table}/ } ], false);

    // END SELECT
    //......................................

    // push this to an object that we will pass to the next builder
    var sql = { SELECT: { template: SELECT, all: SELECTALL } };

    // moving on...
    this.emit("buildInsert", fields, table, sql, hash);

  },

  buildInsert: function(fields, table, sql, hash) {

    //.......................................
    // BEGIN INSERT

    // generate the components to be put into the template and stored for later
    var insertParts = (function(fields) {

      // create the columns entry in their entirety for simplicity
      // for fields that aren't provided at runtime a null value will be
      // supplied so we don't have to calculate which columns to insert
      // each time
      var columns = XT.Tools.values(fields).join(", ");

      // array of just the field names
      var fieldNames = XT.Tools.keys(fields);

      // new array of the fieldnames wrapped in the regex key form
      var values = fieldNames.wrap("{{0}}", []);

      // regex storage
      var regex = {};

      // iterate over the wrapped field keys
      XT.Tools.each(values, function(idx, regexKey) {

        // create the entry in the regex object for use at runtime
        // the `field` can be matched by index here...
        regex[ fieldNames[ idx ] ] = { value: null, regex: new RegExp(regexKey) };

      });

      // the entry into the template for `values` is the wrapped field names
      values = "{0}".format(values.join(", "));

      // return combined result to caller
      return { columns: columns, values: values, regex: regex };

    })(fields);

    var INSERT = XT.Tools.replace(XT.PSQLQueryBuilder.TEMPLATES.INSERT, [
      { value: insertParts.columns, regex: /{columns}/ },
      { value: insertParts.values, regex: /{values}/ },
      { value: table, regex: /{table}/ } ], false);

    // END INSERT
    //.......................................

    sql.INSERT = { template: INSERT, regex: insertParts.regex };

    // hack...
    sql.CREATED = sql.INSERT;

    this.emit("buildUpdate", fields, table, sql, hash);

  },

  buildUpdate: function(fields, table, sql, hash) {

    //.......................................
    // BEGIN UPDATE

    // generate the components to be put into the template and stored for later
    var updateParts = (function(fields) {
      
      // two parts, regex contains the prepprocessed regex expressions and keys,
      // columns will contain the individual columns={key} statements before getting
      // "joined"
      var regex = {}, columns = [];

      // iterate over the fields creating the regex entries and column expressions
      XT.Tools.each(fields, function(field, column) {

        // if the field is the GUID ignore it
        if(field == "guid") return;

        // use the convention for value/regex stored attributes
        regex[ field ] = { value: null, regex: new RegExp("{{0}}".format(field)) };

        // generate them in array prior to being joined...
        columns.push("{0}={{1}}".format(column, field));

      });

      // join the columns into singular string
      columns = columns.join(", ");

      // return combined results to caller
      return { columns: columns, regex: regex };

    })(fields);

    var UPDATE = XT.Tools.replace(XT.PSQLQueryBuilder.TEMPLATES.UPDATE, [
      { value: updateParts.columns, regex: /{columns}/ },
      { value: table, regex: /{table}/ } ], false);

    // END UPDATE
    //.......................................

    sql.UPDATE = { template: UPDATE, regex: updateParts.regex };

    this.emit("buildDelete", fields, table, sql, hash);

  },

  buildDelete: function(fields, table, sql, hash) {

    //.......................................
    // BEGIN DELETE

    var DELETE = XT.Tools.replace(XT.PSQLQueryBuilder.TEMPLATES.DELETE, [
      { value: table, regex: /{table}/ } ], false);

    // END DELETE
    //.......................................

    sql.DELETE = { template: DELETE };

    this.emit("buildToMany", fields, table, sql, hash); 

  },

  buildToMany: function(fields, table, sql, hash) {

    //.......................................
    // BEGIN TOMANY

    var TOMANYSELECT = XT.Tools.replace(XT.PSQLQueryBuilder.TEMPLATES.TOMANY, [
      { value: table, regex: /{table}/ },
      { value: fields.guid, regex: /{column}/ } ], false);

    hash.toManyQuery = XT.PSQLtoManyQuery.create({
      arraySql: TOMANYSELECT,
      sql: sql.SELECT.template,
      fields: fields, 
    });

    // END TOMANY
    //.......................................

    this.emit("buildFinalize", fields, XT.Tools.invert(fields), sql, hash);

  },

  /** @private
    This method is called in the context of a XT.PSQLQuery object and should
    not be called directly.
  */
  buildWhere: function(xtResponse, sql) {

    var json;

    // grab the data associated with the current record type
    if(xtResponse instanceof Array) {
      json = { guid: xtResponse };
    } else if(xtResponse instanceof Object) {
      json = xtResponse.payloadIn[ this.get("sctype") ];
    } else { json = { guid: xtResponse }; }

    // since we are only worrying about the guid...
    // if the value is an array treat them as OR's otherwise its simple...
    var where, self = this;
    if(json.guid instanceof Array) {

    //...................................................
    // THIS IS NOT RIGHT

      where = [];
      XT.Tools.each(json.guid, function(idx, _guid) {
        where.push("{0}={1}".format(self.get("fields.guid"), _guid));
      });
      where = "({0})".format(where.join(" OR "));
    } else {

      // @todo This hack PROVES this needs to have actual data-type handling
      //    but as an interim fix it just guesses...

      var colName = this.get("fields.guid");
      if(colName.indexOf("id") !== -1) {
        where = "{0}={1}".format(colName, json.guid);
      } else { where = "{0}='{1}'".format(colName, json.guid); }
    }

    // NEED TO FIND A WAY TO FIX THIS ^
    //...................................................

    // replace the where field with the generated clause
    sql = sql.template || sql;
    sql = XT.Tools.replace(sql, [
      { value: where, regex: /{where}/ } ], true);

    // return the sql ready to run
    return sql;
  },

  /** @private */
  xtClass: "XT.PSQLQueryBuilder",

});


// a special function of the query builder is to supply a callable
// for the various relation types, so this is the constructor for
// said object/callable that gets used in creating relationcallbacks
XT.PSQLQueryBuilder.toManyConstructor = function(relationDef) {

  /** @private */
  var self = this;

  /** @private
    The XT.Record.toManyQuery object that is callable via "emit"
  */
  self.query = relationDef.relation.get("toManyQuery");

  /** @private */
  self.field = relationDef.field;

  /** @private
    The XT.RecordType being returned to the client.
  */
  self.returning = relationDef.relation.get("sctype");

  /** @private */
  // self.fields = hash.fields;

  /** @private */
  self.exec = function(resultSet, xtResponse) {

    var count = resultSet.length;
    var results = [];

    XT.Tools.each(resultSet, function(idx, row) {

      // the `resultSet` is the actual response from the top level query

      // @note this is being done now by the top-level query handler no need to repeat
      // conversion here
      // var which = resultSet[ idx ][ self.field ] = XT.PSQLQueryBuilder.unwrap(row[ self.field ]);

      var which = row[ self.field ];

      if(which.length > 0) {

        // execute the toManyQuery object and pass the following
        // callback to it
        self.query.emit("exec", which, function(res) {

          // push the results to the results array
          results = results.concat(res);

          // decrement and test for last...
          --count; if(count <= 0) {

            // we are expecting `res` to be formatted and parsed for
            // the return
            xtResponse.send({ returning: self.returning, result: results });

            // @note If this is the last subquery for relations on the original
            //    request then the XT.Response object will automatically detect
            //    that an end the response to the client
          }
        });
      } else {
        --count; if(count <= 0) {
          xtResponse.send({ returning: self.returning, result: results });
        }
      }
    });
  };
};


XT.PSQLQueryBuilder.TEMPLATES = {

  SELECT:   "SELECT {columns}{tomany} FROM {table} WHERE {where}",
  INSERT:   "INSERT INTO {table} ({columns}) VALUES({values})",
  UPDATE:   "UPDATE {table} SET {columns} WHERE {where}",
  DELETE:   "DELETE FROM {table} WHERE {where}",

  // toMany
  TOMANY:   "SELECT {column} AS \"guid\" FROM {table} WHERE {where}",

  // select ALL...
  SELECTALL:"SELECT {columns}{tomany} FROM {table}",

};

/** @private
  PostgrSQL "arrays" returned are strings of comma-separated values wrapped in
  curly braces {}. This method unwraps them and returns the array they SHOULD have
  been.
*/
XT.PSQLQueryBuilder.unwrap = function(array) {
  return array.length > 2
    ? array.substring(1,array.length-1).split(",")
    : []
    ;
};
