
// require some core modules
var UTIL    = require("util");
var PATH    = require("path");

// load into module namespace from above
require("tools");
require("exception");
require("store");
require("functor");

XT.NextFunctor = XT.Functor.create({

  /** @public */
  exec: function(xtResponse, field, xtRecordClass) {

    // need to get a reference to the record type
    var xtRecord = XT.Store.get("recordManager").fetchType(xtRecordClass);

    // if we don't know about this type throw fatal for now
    if(false === xtRecord) XT.throw(new XT.FATAL(
      { message: "XT.NextFunctor doesn't know what {0} is".format(xtRecordClass) }));
  
    // set the xtResponse to be a non-record response

    // @todo This is a reminder that XT.Response needs to be rewritten BADLY
    xtResponse.set("nonRecord");

    // send the XT.Response object and the record class prototype to action
    // to finalize the action

    // special case for `number`
    if(field == "number") {

      // this includes the passed-in (but not seen) numberType variable
      this.emit("action", xtResponse, field, xtRecord.prototype, arguments[ 3 ]);
    } else { this.emit("action", xtResponse, field, xtRecord.prototype); }
  },

  /** @private */
  action: function(xtResponse, field, xtRecordProto) {
    
    // grab the associated SQL
    var sql = this.get("queries.{0}".format(field)), numberType;

    // if for some stupid &#&$!#@# reason we got here and don't have
    // a valid field...punch a wall because it has to be checked
    // and throw an error if it is false!!!
    if(false === sql) {
      XT.throw(XT.E201, "No SQL for field {0} in XT.NextFunctor".format(
        field), xtResponse); return;
    } else {

      // format the SQL to have the correct sequence/number...
      
      // if the field is for a number there is an additional parameter
      if(field == "number") {

        // grab the value
        numberType = arguments[ 3 ];

        // use it in the sql
        sql = sql.format(numberType);
      } else {

        // format the sql
        sql = sql.format(xtRecordProto.get("sequence"));
      }
      
      //.....................................
      // DEVELOPMENT ONLY

      // execute the query and send the result back to the client
      XT.DEVC.query(sql, function(err, res) {

        // on error throw the error response back at the client
        if(err) { XT.throw(XT.E207, err.toString(), xtResponse); return; }

        // fetch the result value, shove it in the response and be on our way
        var value = res[ 0 ].value;

        // send it on back

        // @todo HACK HACK HACK!!!!! Auto-closes...
        xtResponse.sendJson({ value: value });
      });

    }
    
  },

  queries: {
    guid: "SELECT nextval('{0}'::regclass) AS \"value\"",
    number: "SELECT fetchNextNumber('{0}') AS \"value\"",
  },

  /** @private */
  xtClass: "XT.NextFunctor",

});

process.emit("loadedFunctor", XT.NextFunctor);
