
// require some core modules
var UTIL    = require("util");
var PATH    = require("path");

// load into module namespace from above
require("tools");
require("exception");
require("store");

//..........................................
// record manager singleton instance

XT.RecordManager = XT.Object.create({

  /** @private */
  init: function() {

    var self = this;

    // setup listeners for the various events that will
    // fire during initialization
    this.on("definitionLoaded", this.registerRecordType);
    this.on("definitionsLoaded", this.processRecords);
    this.on("recordsProcessed", this.cleanup);
    this.on("recordsProcessed", this.notify);
  },

  //.......................................
  // runtime methods

  /** @private */
  registerRelation: function(hash, type) {
      
    hash.type = type;

    // locally, we need to store the type of relation
    // along with who it belongs to so it is easy
    // and efficient to retrieve it at runtime during
    // retrievals
    var uuid = XT.Store.insert(hash);

    // grab the relations object for registration
    var rels = this.get("relations"), forThis;

    // if this type doesn't have an entry we need to create one
    // as an array of all of the uuid's for any of its relations
    if(!rels.has(hash.self)) {
      rels.set(hash.self, []);
      forThis = rels.get(hash.self);
    } else { forThis = rels.get(hash.self); }

    // push the new uuid to the array
    forThis.push(uuid);

    // need to return the uuid
    return uuid;
  },

  //.......................................
  // initialization methods

  /** @private */
  loadDefinitions: function() {

    // @todo This is not a logical place for the following statement
    //  but it avoids a few lines of code...
    XT.Store.set("recordManager", this);

    // grab the directory of the module so we can use
    // relative pathing and chdir to read files
    var dir = __dirname;

    try {

      // chdir
      process.chdir(dir);

      // grab all of the files in the definitions directory
      var files = XT.Tools.prepend(
        XT.Tools.fs.readDir("./definitions/", [ ".js" ]), "./");


      // @todo Wish I had enough time to create methods to avoid
      //   doing this...
      var count = files.length, self = this;

      // for each of the files we found we need to require them
      // so they can be parsed and in the namespace
      XT.Tools.each(files, function(idx, filename) {
        require(filename);
        --count; if(count == 0) self.emit("definitionsLoaded");
      });

    } catch(e) { XT.throw(new XT.FATAL({ message: e, stack: e.stack })); }

  },

  /** @private */
  processRecords: function() {
    
    // grab the registered record names and their definitions
    var types = this.get("types"), count = XT.Tools.keys(types).length, self = this;

    // iterate over them and asynchronously pass them to the
    // query builder (part of driver that is also a part of
    // the store)
    XT.Tools.each(types, function(xtRecordType, xtRecordDef) {
      XT.Store.driver.queryBuilder.build(xtRecordType, xtRecordDef);
      --count; if(count == 0) self.emit("recordsProcessed", "recordsProcessed");
    });
  },

  /** @private */
  registerRecordType: function(xtRecord) {
    this.get("types")[ xtRecord.prototype.xtClass ] = xtRecord;
  },

  /** @private */
  fetchType: function(xtRecordType) {
    return this.get("types")[ xtRecordType ];
  },

  /** @private */
  fetch: function(xtRecordType) {
    return XT.Store.fetchQuery(xtRecordType);
  },

  /** @private */
  relationsFor: function(xtRecordType) {
    return this.get("relations").get(xtRecordType);
  },

  /** @private
    We can't build the relations until ALL of the records have been processed at the
    query objects generated for them. Once that is completed they each get passed
    through this method to build and load the relations objects onto them so it
    only has to be done once.
  */
  loadRelations: function(xtQuery) {

    // the query knows its recordType
    var type = xtQuery.get("type"), fields = xtQuery.get("fields");
    // all relations for this type are here
    // var relations = this.get("relations").get(type);
    var relations = this.relationsFor(type);

    // if there aren't any, then set hasRelations to false
    // and move on, otherwise need to grab all of them from
    // the store and attach them to the query
    if(relations && relations.length > 0) {

      // array to be used to build the toMany subquery arrays on the main
      // select sql code
      var toManySql = [];

      // set the boolean to true

      
      //...............................................
      // THIS HAS BEEN ARBITRARILY DISABLED FOR NOW
      // NO NESTED DATA IS RETURNED, ONLY TOP-LEVEL REQUESTS

      // TO ALLOW NESTED RESPONSES SWITCH THIS TO TRUE
      xtQuery.hasRelations = false;

      // iterate over the relations for the record type
      XT.Tools.each(relations, function(idx, uuid) {

        // grab the relation from the store
        var relation = XT.Store.fetch(uuid);

        // if for some reason its a null, return to continue
        if(!relation) return;

        // find the entry for the type on the query object
        // by matching its uuid then replace it properly
        var typeFor = xtQuery.get(relation.type);
        
        // iterate of them to find the one we're matching on
        XT.Tools.each(typeFor, function(field, _uuid) {

          // if they are the same
          if(uuid === _uuid) {
            
            // set the xtQuery's entry for this type to the relation
            typeFor[ field ] = (function(relationDef, field, fields) {

              // grab the queries for the types we're building on
              // since ultimately the query holds the information we
              // need for the records
              relationDef.self = XT.Store.fetchQuery(relationDef.self);
              relationDef.relation = XT.Store.fetchQuery(relationDef.relation);
              relationDef.field = field;
              relationDef.fields = fields;

              if(relationDef.type == "toMany") {

                // push the relation to the array to build the toMany statements...
                toManySql.push(relationDef);

                // return a new constructor for relations
                return new XT.PSQLQueryBuilder.toManyConstructor(relationDef);
              } else { return "[TO ONE RELATIONS NEVER IMPLEMENTED - NEED CONSTRUCTOR DEFINED]"; }

            })(relation, field, fields);

            // return false so it will not keep looking
            return false;
          }
        });
      });

      if(toManySql.length > 0) {

        // for each of the relations we have to add the subquery
        XT.Tools.each(toManySql, function(idx, def) {

          // to house the where statement parts as they are determined
          var where = [];

          // there will be at least 1
          where.push("{0}={1}".format(

            // this is the definiton's relation element's fields where `to` is the field
            // of the relation (being converted to actual column name) set to equal the
            // current record type's (`on`) field (converted to column name)
            def.relation.fields[ def.to ], xtQuery.fields[ def.on ]));

          // if there are static's that have been defined, they are already stringed together
          // so just stash them on there with the rest
          if(def.static) where.push(def.static);

          // each toMany has 2 parts, the array in the top-level query of id's (guid's) and
          // then the optional nested object query that gets returned with the top-level
          // query
          toManySql[ idx ] = "array({0}) AS \"{1}\"".format(XT.Tools.replace(
            def.relation.toManyQuery.arraySql, [
              { value: where.join(" AND "), regex: /{where}/ } ], false), def.field);
        });

        // push in the previously determined toMany array sub-queries into the top-level query
        // for this record type
        xtQuery.SELECT.template = XT.Tools.replace(xtQuery.SELECT.template, [
          { value: ", {0} ".format(toManySql.join(", ")), regex: /{tomany}/ } ], false);
      } else {

        // if there was/were only toOne relations defined then we need to wipe
        // the {tomany} key...

        // @todo Make all this cleanup automatic?

        XT.Tools.each(xtQuery.SELECT, function(key, entry) {
          xtQuery.SELECT[ key ] = XT.Tools.replace(entry, [
            { value: "", regex: /{tomany}/ } ], false);
        });

      }
      
    } else { 

      // so it is known it does not need to calculate relations
      xtQuery.hasRelations = false;

      // need to wipe out the {tomany} key from the query template

      // @note This was already being done in the where-builder BUT
      //    for queries running SELECTALL this has to be done here
      //    better to get it done before rather than at runtime
      
      XT.Tools.each(xtQuery.SELECT, function(key, entry) {
        xtQuery.SELECT[ key ] = XT.Tools.replace(entry, [
          { value: "", regex: /{tomany}/ } ], false);
      });
    }

  },

  /** @private */
  notify: function(eventName) {

    // @note For now notifications just go to the store
    XT.Store.emit(eventName);
  },

  /** @private */ 
  cleanup: function() {

    // remove unneeded listeners that were setup during
    // initialization
    this.removeListener("definitionsLoaded", this.processRecords);
    this.removeListener("recordsProcessed", this.cleanup); 
    this.removeListener("definitionLoaded", this.registerRecordType);
  },

  /** @private */
  types: {},

  /** @private */
  relations: XT.Object.create({

    /** @private */
    xtClass: "XT.RecordManager.relations"

  }),

  /** @private */
  xtClass: "XT.RecordManager",

}).loadDefinitions();
