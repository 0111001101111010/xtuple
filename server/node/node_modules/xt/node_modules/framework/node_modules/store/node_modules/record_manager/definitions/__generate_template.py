#!/usr/bin/python

# FOR 2.6 (default in Mac OS 10.6)
# @author W. Cole Davis

from optparse import OptionParser
from datetime import date
from types import *

import os
import re
import io

# @todo Need to add features: (comma-separated lists of) toMany, toOne relations, etc.
parser = OptionParser()
parser.add_option("-n", "--name", dest="name", help="XT record-type without 'XT' namespace, expects CamelCase [ REQUIRED ]")
parser.add_option("-d", "--dest", dest="dir", help="The destination directory for the file")
parser.add_option("-t", "--table", dest="table", help="The PostgreSQL table name")
parser.add_option("-s", "--schema", dest="schema", help="The PostgreSQL schema name")
parser.add_option("-p", "--primary", dest="primary", help="The PostgreSQL column to be referred to as `guid`")
parser.add_option("-O", "--toOne", dest="toOne", help="A comma-separated list of toOne relations (by field-name, no spaces else use quotes) to create entries for")
parser.add_option("-M", "--toMany", dest="toMany", help="A comma-separated list of toMany relations (by field-name, no spaces else user quotes) to create entries for")
parser.add_option("-f", "--fields", dest="fields", help="A comma-separated list of fields to create entries for, if prefix provided, all will already be prefixed")
parser.add_option("-r", "--prefix", dest="prefix", help="The table prefix (e.g. cntct_) to be prepended to field-entries for convenience")


(options, args) = parser.parse_args()

name=options.name
destdir=options.dir
table=options.table or "{POSTGRES_TABLE_NAME}"
schema=options.schema or "{POSTGRES_SCHEMA_NAME}"
primary=options.primary or "{POSTGRES_TABLE_PRIMARY_KEY}"
toOnes=options.toOne or "{TOONE_RELATIONS}"
prefix=options.prefix or ""
fields=options.fields or "{FIELD_NAMES}"

# make sure we have a value for name
if name == None:
  parser.print_help()
  exit(-1)

# if there were multiple toOne relations defined, separate those out
if toOnes != "{TOONE_RELATIONS}":
  toOnes=toOnes.split(",")
  if isinstance(toOnes, str):
    toOnes=list(toOnes)

# if there were fields entered separate those out
if fields != "{FIELD_NAMES}":
  fields=fields.split(",")
  if isinstance(fields, str):
    fields=list(fields)

# normalize for a filename
norm=re.compile("(?<!^)[A-Z]")
def replace(match):
  return "_%s" % (match.lower())
destfile=norm.sub(lambda m: replace(m.group()), name).lower() + ".js"

#......................................
# SANITY

# if no destination dir provided use current directory
if destdir == None:
  destdir=os.getcwd()
else: destdir=os.path.abspath(destdir)

# check if we have write ability for directory
if os.access(destdir, os.W_OK):
  print("Can write to directory: OK")
else:
  print("Can write to directory: NO")
  exit(-1)

# push the file onto the validated path
destfile=os.path.join(destdir, destfile)

# check if the file already exists
if os.path.exists(destfile):
  print("File %s already exists, will not continue" % (os.path.basename(destfile)))
  exit(-1)
else: print("File %s does not exist, will create new" % (os.path.basename(destfile)))

# END
#.......................................

# enumerable list of lines to be added to the generated file
lines=[]

lines.append(r"""
// generated by __generate_template.py (on %s)

// require some core modules
var UTIL    = require("util");
var PATH    = require("path");

// load into module namespace from above
require("tools");
require("exception");
require("store");

// load into module namespace from level
require("record");

""" % (date.today().isoformat()));

lines.append(r"""
XT.%s = XT.Record.extend({

  definition: {

    // sproutcore record equivalent
    sctype: "XT.%s",

    // postgres table
    table: "%s",

    // postgres schema
    schema: "%s",

    // fields as columns
    fields: {
""" % (name, name, table, schema))

lines.append(r"""

      //...................................
      // sproutcore fields

      guid:                 "%s",

      // FOLLOW SUIT WITH ENTRIES IN THE FORM
      // {SPROUTCORE_FIELD} => {POSTGRES_COLUMN} (without braces or arrow...)
      // FIELDS MUST BE DEFINED EVEN IF IT HAS A TOMANY OR TOONE RELATION

""" % (primary))

# fill in the fields...if any
if type(fields) is ListType:
  for field in fields:
    lines.append(r"""
      
      %s:             "%s",
""" % (field, prefix))
else:
  lines.append(r"""
    
    // %s,
""" % (fields))

lines.append(r"""

    },

    //..................................
    // toMany mappings

    toMany: {

      /** @example
        
        The following can be found in the XT.CrmAccount definition:

        comments:       XT.Record.toMany({
                          self:     "XT.CrmAccount",
                          relation: "XT.Comment",
                          on:       "guid",
                          to:       "source",
                          static:   XT.Record.static({ "comment_source":"'CRMA'" }),
                        }),

      */

    }, // toMany

    //....................................
    // toOne mappings

    toOne: {

      /** @example

        The following can be found in the XT.CrmAccount definition:

        primaryContact:     XT.Record.toOne({
                              self:     "XT.CrmAccount",
                              relation: "XT.Contact",
                              to:       "guid",
                            }),

      */
""")

# generate entries for any toOne relations defined on the command-line
if type(toOnes) is ListType:
  for one in toOnes:
    lines.append(r"""

        %s:                XT.Record.toOne({ // wasn't worth the effort to allign this perfectly...
                              self:     "XT.%s",
                              relation: "{RELATION_NAME}",
                              to:       "guid", // change-me if needed!
                            }),
    """ % (one, name))
else:
  lines.append(r"""
      // %s
  """ % (toOnes))

lines.append(r"""

    }, // toOne

  }, // definition

  /** @private */
  xtClass: "XT.%s",

});

XT.Store.recordManager.emit("definitionLoaded", XT.%s);
""" % (name, name))

# open the file for a steam really, not descriptor, but...oh well
with io.open(destfile, "wb") as file:

  # write lines to file
  file.writelines(lines)

  # flush to be sure
  file.flush()

  # close stream
  file.close()

print("Done")

# clean exit
exit(0)
